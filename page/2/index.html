<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>王璐的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="王璐的博客">
<meta property="og:url" content="http:/page/2/index.html">
<meta property="og:site_name" content="王璐的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王璐的博客">
  
    <link rel="alternate" href="/atom.xml" title="王璐的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">王璐的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http:"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android/Android-自定义控件PickerView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-自定义控件PickerView/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-自定义控件PickerView/">Android-自定义控件PickerView</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间在公司总是有需求『滚动的选择器』，那时候总是用别人写好的来用，感觉心里不是很舒服，最近有时间了自己来写一写，上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-6d1e3f570799130a.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>首先分析一下需求：</p>
<ol>
<li>可以滑动</li>
<li>滑到两条线里的数据变色</li>
<li>滑动完成后必须要把选中的数据放到中间</li>
</ol>
<h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><p>首先说到滑动而且还是自定义的View，我们就会想到各种『scrollBy/scrollTo』等，但是这里有个更简单的方法就是<strong>继承自ScrollView</strong>，这样就简单了不少，并且还有滚动的监听『只不过少了一个停止滑动的状态』，然而对于这个需求，我们只需要创建一个ViewGroup来放入数据（也就是很多TextView），然后addView()就OK，代码如下：</p>
<pre><code>/**
 * 初始化数据,首先添加Group
 */
mTextGroup = new LinearLayout(context);
mTextGroup.setOrientation(LinearLayout.VERTICAL);
mTextGroup.setGravity(Gravity.CENTER);
addView(mTextGroup);


/**
 * 由于我们需要给自身的数据在选中的框里显示
 * 所以这里需要添加前面和后面的空数据
 */
mTextGroup.addView(createTextView(&quot;&quot;));
for (int i = 0; i &lt; mData.size(); i++) {
    mTextGroup.addView(createTextView(&quot;&quot; + mData.get(i)));
}
mTextGroup.addView(createTextView(&quot;&quot;));

------------------------------------------------------------

/**
 * 动态创建TextView
 */
private TextView createTextView(String s) {
    TextView tv = new TextView(context);
    tv.setText(s);
    tv.setTextColor(getResources().getColor(android.R.color.darker_gray));
    tv.setTextSize(mTextSize);
    LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, mTextHeight);

    params.bottomMargin = mTextHeight / 2;
    params.topMargin = mTextHeight / 2;
    tv.setLayoutParams(params);
    return tv;
}
</code></pre><p>可以看到我们在数据的前后都加了两条空数据，因为这里需要在滑动到底部或者顶部的时候确保第一条或者最后一条数据是在我们的两条线之内，这样运行一下程序就会发现我们的数据已经可以滑动了，只不过这个时候还没有中间的两条线。这里需要思考一下，如果我们添加两条线上去的话，滑动的时候线也会跟着滑动，所以这个时候就想到了背景，我们自己来画一个背景。代码如下：</p>
<pre><code>/**
 * 设置背景,这里选择画一个,两条线
 */
setBackground(new Drawable() {
    @Override
    public void draw(Canvas canvas) {
        /**
         * 这里把两条线之间的距离设置为了两个TextView的高度
         */
        canvas.drawLine(
                mWidth * 0.1f,
                mHeight / 2 - mTextHeight,
                mWidth * 0.9f,
                mHeight / 2 - mTextHeight,
                mLinePaint
        );
        canvas.drawLine(
                mWidth * 0.1f,
                mHeight / 2 + mTextHeight,
                mWidth * 0.9f,
                mHeight / 2 + mTextHeight,
                mLinePaint
        );
    }

    @Override
    public void setAlpha(int i) {

    }

    @Override
    public void setColorFilter(ColorFilter colorFilter) {

    }

    @Override
    public int getOpacity() {
        return 0;
    }
});
</code></pre><p>这时候我们的背景和数据都弄好了</p>
<h3 id="在线内的数据变颜色"><a href="#在线内的数据变颜色" class="headerlink" title="在线内的数据变颜色"></a>在线内的数据变颜色</h3><p>先考虑一下，因为我们使用的是TextView，所以我们直接就可以设置TextView的字体颜色。很简单，我们在onScrollChanged()方法中用小学除法来算一下当前滚动到了哪个TextView『也就是position』，我们就把哪个改变颜色，代码如下：</p>
<pre><code>/**
 * ScrollView的滑动事件监听
 */
@Override
protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);

    /**
     * 计算出当前在两条线里的position
     */
    position = (t + mTextHeight) / (mTextHeight * 2);
    /**
     * 因为此方法会在滑动的时候不停的调用,所以这里设置一个临时的变量来控制
     */
    if (tempPosition != position) {
        int size = mTextGroup.getChildCount();
        for (int i = 0; i &lt; size; i++) {
            TextView tv = (TextView) mTextGroup.getChildAt(i);
            /**
             * 因为我们在数据开头添加了一个空的数据,所以这里position要+1
             */
            if (position + 1 == i) {
                tv.setTextColor(getResources().
                        getColor(android.R.color.holo_blue_dark));
            } else {
                tv.setTextColor(getResources().
                        getColor(android.R.color.darker_gray));
            }
        }
    }
    tempPosition = position;
}
</code></pre><h3 id="滑动结束后把当前数据放在中间（其实我不知道怎么表达了）"><a href="#滑动结束后把当前数据放在中间（其实我不知道怎么表达了）" class="headerlink" title="滑动结束后把当前数据放在中间（其实我不知道怎么表达了）"></a>滑动结束后把当前数据放在中间（其实我不知道怎么表达了）</h3><p>ScrollView没有滑动结束的监听，所以我们只好取巧来弄一个。我们在手指离开屏幕的30ms后来判断当前的scrollY和离开屏幕时候的scrollY是否一样，一样则认定是滑动结束了，如果不一样，我们强行给弄成一样的来结束滑动</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent ev) {
    /**
     * 因为ScrollView没有停止滑动的监听,所以这里取巧
     * 在手指离开屏幕的30ms后判断是否和原来的scrollY一样
     * 如果一样则进入,如果不一样则设置为一样
     */
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        scrollY = getScrollY();
        postDelayed(new Runnable() {
            @Override
            public void run() {
                if (scrollY == getScrollY()) {
                    /**
                     * 获得每次松手后scrollY相对于TextView高度的偏移量
                     */
                    int offset = scrollY % (mTextHeight * 2);

                    /**
                     * 如果偏移量大于TextView高度的一半
                     * 则进入到下一个
                     */
                    if (offset &gt; mTextHeight) {
                        smoothScrollTo(0, scrollY - offset + (mTextHeight * 2));
                    } else {
                        smoothScrollTo(0, scrollY - offset);
                    }
                } else {
                    scrollY = getScrollY();
                    post(this);
                }
            }
        }, 30);
    }
    return super.onTouchEvent(ev);
}
</code></pre><p>到这里就结束了，其实还是蛮简单的，只不过功能甚少，只能实现基本的选择数据，所以我起名为PickerView，当然以后还会对这个项目进行维护，已经上传github，地址<a href="https://github.com/wanglu1209/PickerView" target="_blank" rel="noopener">PickerView</a>，欢迎大家来star或者提bug</p>
<hr>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><p>感谢wangjiegulu的WheelView给的启发，放上地址</p>
<p><a href="https://github.com/wangjiegulu/WheelView" target="_blank" rel="noopener">WheelView</a></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-自定义控件PickerView/" data-id="cjfx8xufu000aqqfyn5bmwylh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-触摸事件的分发和处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-触摸事件的分发和处理/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-触摸事件的分发和处理/">Android-触摸事件的分发和处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="首先想要了解事件的分发和处理，就要先了解什么是触摸事件"><a href="#首先想要了解事件的分发和处理，就要先了解什么是触摸事件" class="headerlink" title="首先想要了解事件的分发和处理，就要先了解什么是触摸事件"></a>首先想要了解事件的分发和处理，就要先了解什么是触摸事件</h3><hr>
<blockquote>
<p>什么是触摸事件？</p>
</blockquote>
<p>顾名思义，触摸事件就是我们触碰屏幕之后产生的事件，一般触碰到屏幕之后会触发两个或者三个事件</p>
<ol>
<li>按下        Action_Down</li>
<li>如果滑动    Action_Move</li>
<li>抬起        Action_Up</li>
</ol>
<p>这些事件封装成了一个类『MotionEvent』，如果重写onTouchEvent()方法，该方法的参数就是一个MotionEvent对象。在MotionEvent里不止有这几个事件，还可以取出当前触摸的坐标点等等。</p>
<hr>
<p>当然，这只是在一个View中，但是我们知道，Android的View结构是树形的，View可以放在一个ViewGroup当中，然后这个ViewGroup当中又嵌套一个ViewGroup。所以当我触摸屏幕的时候到底是谁来执行这个事件？这样就引出了『事件拦截』</p>
<p><strong>我们想象一下场景</strong></p>
<p>一个总经理，一个技术经理，然后干活的你。总经理把任务布置给技术经理，然后技术经理把任务安排给了你。过了一会你把任务完成，交给技术经理，技术经理觉的不错，就交给了总经理，这样这个任务就完成了</p>
<p>了解了这个流程之后，对于事件拦截也就理解了小半了，下面来一个实例看一下</p>
<hr>
<p>首先我们自定义两个ViewGroup和一个View分别对应一个总经理一个技术经理和一个干活的。</p>
<p>在两个ViewGroup中我们主要重写三个方法</p>
<ol>
<li>dispatchTouchEvent()</li>
<li>onInterceptTouchEvent()</li>
<li>onTouchEvent()</li>
</ol>
<p>然后在View中重写两个方法</p>
<ol>
<li>dispatchTouchEvent()</li>
<li>onTouchEvent()</li>
</ol>
<p>然后我们在这几个方法中什么都不改，只是在里面打印Log日志来看一下执行的顺序。</p>
<p>XML布局如下：</p>
<pre><code>&lt;com.github.wanglu1209.androidqunyingzhuan.ViewGroupA
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;com.github.wanglu1209.androidqunyingzhuan.ViewGroupB
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;com.github.wanglu1209.androidqunyingzhuan.MyView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;/com.github.wanglu1209.androidqunyingzhuan.ViewGroupB&gt;

&lt;/com.github.wanglu1209.androidqunyingzhuan.ViewGroupA&gt;
</code></pre><p>现在运行程序，查看Log，如下：</p>
<blockquote>
<p>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupB dispatchTouchEvent<br>ViewGroupB onInterceptTouchEvent<br>View dispatchTouchEvent<br>View onTouchEvent<br>ViewGroupB onTouchEvent<br>ViewGroupA onTouchEvent</p>
</blockquote>
<p>可以看的出来，正常情况下事件的传递顺序为：</p>
<p>ViewGroupA -&gt; ViewGroupB -&gt; View</p>
<p>事件的处理顺序为：</p>
<p>View -&gt; ViewGroupB -&gt; ViewGroupA</p>
<p>其中事件传递的返回值：</p>
<ol>
<li>True 拦截，不继续传递</li>
<li>False 不拦截，传递</li>
</ol>
<p>事件处理的返回值：</p>
<ol>
<li>True 处理完毕，不交给上级</li>
<li>False 交给上级</li>
</ol>
<blockquote>
<p>事件分发</p>
</blockquote>
<p><strong>现在我们给代码做一些改动，把ViewGroupA的onInterceptTouchEvent()的返回值改为True，查看一下log</strong></p>
<p>log如下：</p>
<blockquote>
<p>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupA onTouchEvent</p>
</blockquote>
<p>这里我们直接在最外侧的ViewGroupA中把事件拦截了下来，所以后面的ViewGroupB和View都没有接收到触摸事件。如果我们在ViewGroupB中拦截事件，那么log如下；</p>
<blockquote>
<p>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupB dispatchTouchEvent<br>ViewGroupB onInterceptTouchEvent<br>ViewGroupB onTouchEvent<br>ViewGroupA onTouchEvent</p>
</blockquote>
<p>这样把Log打印出来就对事件的拦截和传递有了一个清晰的认识，下面来看一下事件的处理</p>
<hr>
<blockquote>
<p>事件处理</p>
</blockquote>
<p>开始的时候我们说过，当你完成了任务之后会像你的项目经理报告，需要上级的确认，所以你的事件处理返回false，如果有一天你不干了，那么你也就不用给上级报告了，返回了true，来看一下log</p>
<blockquote>
<p>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupB dispatchTouchEvent<br>ViewGroupB onInterceptTouchEvent<br>View dispatchTouchEvent<br>View onTouchEvent<br>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupB dispatchTouchEvent<br>ViewGroupB onInterceptTouchEvent<br>View dispatchTouchEvent<br>View onTouchEvent</p>
</blockquote>
<p>事件传递和以前一样依次的传递下来，但是处理事件到View这里就结束了，没有向上级传递，如果给ViewGroupB的onTouchEvent的返回值true，那么事件处理到ViewGroupB就结束了。</p>
<p>这样一来，事件的分发和处理就了解了</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-触摸事件的分发和处理/" data-id="cjfx8xufw000bqqfy5cupuqp2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-Activity启动模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-Activity启动模式详解/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-Activity启动模式详解/">Android-Activity启动模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="最近在写一个小Demo（然而现在也没写出来）。几天没更新，不知道有没有人还有一点点的小期待（估计没有）。让我边写文章边哭一会。。。"><a href="#最近在写一个小Demo（然而现在也没写出来）。几天没更新，不知道有没有人还有一点点的小期待（估计没有）。让我边写文章边哭一会。。。" class="headerlink" title="最近在写一个小Demo（然而现在也没写出来）。几天没更新，不知道有没有人还有一点点的小期待（估计没有）。让我边写文章边哭一会。。。"></a>最近在写一个小Demo（然而现在也没写出来）。几天没更新，不知道有没有人还有一点点的小期待（估计没有）。让我边写文章边哭一会。。。</h4><hr>
<h2 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h2><blockquote>
<p>为啥子需要启动模式？</p>
</blockquote>
<p>我们知道启动Activity时会把Activity放入一个任务栈，所以当我们按back键时就会从Activity从任务栈里清除，当任务栈里为空时，系统就会回收这个任务栈。<strong>举个例子</strong>，我们在当前Activity启动当前的Activity，那么任务栈里就全是当前Activity，这样当然很二逼了！所以启动模式就出来了，目前有四种启动模式</p>
<ul>
<li>standard</li>
<li>singleTop</li>
<li>singleTask</li>
<li>singleInstance</li>
</ul>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>standard是标准模式，也就是默认模式。每次启动一个Activity就会创建一个新的实例，不管这个实例是否已经存在，<strong>这就是典型的多实例实现。一个任务栈可以有多个实例，每个实例也可以属于不同的任务栈，谁启动了这个Activity，这个Activity就运行在启动它的那个任务栈中，</strong>当我们用ApplicationContext去启动一个standard模式的Activity会报错，因为standard的Activity会进入启动他的Activity任务栈中，但是由于非Activity类型的Context并没有任务栈，所以这样就出问题了</p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>singleTop即栈顶复用模式，在这种模式下，如果新创建的Activity已经位于栈顶，那么就不会去创建新的实例，但是该Activity的onNewIntent会被调用，通过这个方法我们可以取出请求的信息。<strong>需要注意的是，该Activity的onCreate、onStart不会被调用，因为它没有发生改变。</strong>但是如果新的Activity不位于栈顶，那么就会创建一个新的实例。<strong>举个例子</strong>，比如现在一个任务栈有ABCD四个Activity，A位于栈底，D位于栈顶。这个时候如果去启动D，那么栈的情况还是ABCD四个实例，如果D的启动模式为standard，那么栈内就是ABCDD</p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>栈内复用模式，在这种模式情况下，只要Activity在一个栈中存在，那么启动这个Activity都不会重新创建实例，也会调用onNewIntent。<strong>当一个singleTask模式的Activity『A』被请求启动，首先系统会寻找是否有A所需的任务栈，如果不存在，那就重新创建一个任务栈，然后创建A的实例放入栈中。如果存在A所需的任务栈，这时再看A是否在这个栈中有实例存在，如果存在，那么久回把A调到栈顶并调用onNewIntent方法。如果不存在，那么就创建A的实例并且压入栈中，举个例子</strong></p>
<ul>
<li>比如当前任务栈S1中有ABC三个实例，这个时候singleTask模式的D启动，但是其所需要的任务栈为S2，由于S2和D的实例都不存在，这个时候就会先创建S2任务栈，然后创建D的实例压栈到S2</li>
<li>如果D需要的任务栈为S1，那么由于任务栈S1已经存在，所以直接会创建D的实例放到S1任务栈中</li>
<li>如果D需要的任务栈为S1，并且S1的情况为ADBC，这时不会重新创建D的实例，会把D调用栈顶，同时<strong>singleTask默认具有clearTop效果，所以会导致D上面的Activity全部出栈</strong>，于是最终S1的情况为AD</li>
</ul>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>单例模式，加强的singleTask，这种模式的Activity只能单独运行在一个单独的任务栈中，其他和singleTask一样</p>
<blockquote>
<p>所需的任务栈？</p>
</blockquote>
<p>在singleTask中提到『所需的任务栈』，什么是Activity所需的任务栈？这里就要提一个参数：TaskAffinity。这个参数标识了一个Activity所需的任务栈的名字，默认情况下所有的Activity所需的任务栈都是当前包名，当然我们也可以为每个Activity单独指定TaskAffinity，<strong>注意这个属性值必须不能和包名相同，</strong>TaskAffinity主要和singleTask配合使用，否则的话没什么意义。当启动一个被TaskAffinity标识了的Activity，那么该Activity就会运行在和TaskAffinity相同的任务栈中</p>
<p>我们用两种方式设置Activity的启动模式</p>
<ol>
<li>在AndroidManifest里为Activity设置<br><code>android:launchMode=&quot;singleTop/singleTask/singleInstance&quot;</code></li>
<li>通过Intent设置标志位来指定<br><code>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</code></li>
</ol>
<p>这两种方式<strong>第二种的优先级要高于第一种，也就是说两者同时存在时，以第二种为准</strong></p>
<hr>
<h2 id="强行举个特殊的例子"><a href="#强行举个特殊的例子" class="headerlink" title="强行举个特殊的例子"></a>强行举个特殊的例子</h2><p>如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-2e7d2017412beb22.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>首先我们看一下AndroidManifest里的配置</p>
<pre><code>&lt;activity android:name=&quot;.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

&lt;activity
    android:name=&quot;.SecondActivity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;com.task1&quot; /&gt;

&lt;activity
    android:name=&quot;.ThirdActivity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;com.task1&quot; /&gt;
</code></pre><p>可以看到我们给SecondActivity和ThirdActivity设置了singleTask模式和taskAffinity，也就是所需的任务栈。从图里我们可以看出，首先由MainActivity启动SecondActivity，然后由SecondActivity启动ThirdActivity，再由ThirdActivity启动MainActivity，最后再启动SecondActivity。然后我们按两次回退键，发现回到了桌面了，这是为什么？</p>
<p>首先我们把MainActivity设为A，SecondActivity为B，ThirdActivity为C。</p>
<p>从Manifest文件中可以看到A为standard模式，任务栈为包名，而B和C是singleTask模式，任务栈为com.task1。</p>
<p>所以当我们从A启动B的时候，系统会为我们新建一个任务栈，就是com.task1，从而把B进栈。</p>
<p>从B启动C时，发现C所需要的任务栈com.task1已经存在，但是没有发现C的实例，这时候就创建C的实例并且进栈，这时com.task1里为BC</p>
<p>然后我们又从C启动A，由于A为standard模式，所以A会进入到C的任务栈，这时有两个任务栈存在，一个是为包名的任务栈，一个是为com.task1的任务栈。包名的任务栈里只有一个A，而com.task1的任务栈里现在是BCA</p>
<p>接着我们由A启动B，B是singleTask模式，而恰好当前栈里存在着B的实例，所以不会重新创建实例，而是把B调到栈顶，并且把前面的Activity通通出栈，此时com.task1的任务栈里就只剩下一个B了</p>
<p>最后我们按下一次回退键，当前B被出栈，com.task1任务栈被销毁，调出包名任务栈，也就是A，然后再按一次就退出程序了，这也就间接的证明了切换singleTask模式的Activity会把在它之上的Activity出栈。</p>
<hr>
<p>写了这么多字累死我了</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-Activity启动模式详解/" data-id="cjfx8xufe0002qqfy0ppu3owq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-ViewDragHelper" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-ViewDragHelper/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-ViewDragHelper/">Android-ViewDragHelper</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h2><hr>
<p>我们都知道在Google发布的support包中包含了DrawerLayout和SlidingPaneLayout这两个可以滑动的控件，其实这两个布局背后就隐藏着ViewDragHelper。通过ViewDragHelper基本上的滑动需求都可以满足，所以这个方法是<strong>各种滑动解决方案的终极绝招</strong></p>
<p>下面我们来进行一个实例，来使用一下ViewDragHelper，类似于QQ的侧滑菜单。废话不多说，上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-6892239ec9b94b03.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h3 id="使用ViewDragHelper"><a href="#使用ViewDragHelper" class="headerlink" title="使用ViewDragHelper"></a>使用ViewDragHelper</h3><ol>
<li>初始化ViewDragHelper</li>
<li>重写拦截、触摸事件交给ViewDragHelper处理</li>
<li>处理computeScroll()</li>
<li>处理回调接口Callback</li>
</ol>
<h3 id="初始化ViewDragHelper"><a href="#初始化ViewDragHelper" class="headerlink" title="初始化ViewDragHelper"></a>初始化ViewDragHelper</h3><p>ViewDragHelper<strong>通常定义在一个ViewGroup的内部，并通过静态工厂方法进行初始化，</strong>代码如下：</p>
<pre><code>mHelper = ViewDragHelper.create(this, callback);
</code></pre><p>对，就这一行代码，这里的this就是只一个ViewGroup了，callback就是刚才我们说的回调接口</p>
<h3 id="重写拦截、触摸事件交给ViewDragHelper处理"><a href="#重写拦截、触摸事件交给ViewDragHelper处理" class="headerlink" title="重写拦截、触摸事件交给ViewDragHelper处理"></a>重写拦截、触摸事件交给ViewDragHelper处理</h3><pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {
    mHelper.processTouchEvent(event);
    return true;
}

@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    return mHelper.shouldInterceptTouchEvent(ev);
}
</code></pre><p>这里就是一个事件拦截和触摸事件监听，上一文中都讲过，这里不在多说，就是调用了DragViewHelper的两个方法而已</p>
<h3 id="处理computeScroll"><a href="#处理computeScroll" class="headerlink" title="处理computeScroll()"></a>处理computeScroll()</h3><p>因为ViewDragHelper也是通过Scroller来实现平滑移动的，所以我们要重写computeScroll()方法，一般代码如下：</p>
<pre><code>@Override
public void computeScroll() {
    if (mHelper.continueSettling(true)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
}
</code></pre><h3 id="处理回调接口Callback"><a href="#处理回调接口Callback" class="headerlink" title="处理回调接口Callback"></a>处理回调接口Callback</h3><p>处理回调接口就是最关键的代码了，我们一般需要重写这几个方法</p>
<ul>
<li>tryCaptureView<ul>
<li>这个方法是自动创建的，通过这个方法可以指定哪一个子View可以移动</li>
</ul>
</li>
<li>clampViewPositionHorizontal<ul>
<li>这个方法对应的是水平上的滑动</li>
</ul>
</li>
<li>clampViewPositionVertical<ul>
<li>这个方法对应的是垂直上的滑动</li>
<li>如果想要滑动，这两个方法是必须要重写其中一个或者全部重写的，因为方法默认返回0，即不发生滑动</li>
</ul>
</li>
<li>onViewReleased<ul>
<li>这个方法在手指离开屏幕后调用</li>
</ul>
</li>
</ul>
<p>不多说，直接把代码撸上来，非常简单，对照注释一看就懂，整体代码如下</p>
<pre><code>public class ViewDragHelperDemo extends FrameLayout {

    ViewDragHelper mHelper;
    View mainView, menuView;

    public ViewDragHelperDemo(Context context) {
        this(context, null);
    }

    public ViewDragHelperDemo(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public ViewDragHelperDemo(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        /**
         * 初始化ViewDragHelper
         */
        mHelper = ViewDragHelper.create(this, callback);
    }


    ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {
        @Override
        public boolean tryCaptureView(View child, int pointerId) {
            /**
             * 决定滑动的View
             */
            return child == mainView;
        }

        @Override
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            /**
             * 水平方向上的移动
             */
            return left;
        }

        @Override
        public void onViewReleased(View releasedChild, float xvel, float yvel) {
            super.onViewReleased(releasedChild, xvel, yvel);
            /**
             * 当手指离开屏幕后,如果当前移动的View和父布局之间的距离小于150,那么则移动回原位
             * 如果大于150,那么则滑动到300
             */
            if (mainView.getLeft() &lt; 150) {
                mHelper.smoothSlideViewTo(mainView, 0, 0);
            }else{
                mHelper.smoothSlideViewTo(mainView, 300, 0);
            }

            /**
             * 通知重绘
             */
            ViewCompat.postInvalidateOnAnimation(DragViewHelperDemo.this);
        }
    };

    /**
     * 此方法会在布局加载完毕调用,我们把第一个布局设置为menuView,第二个设置为mainView
     */
    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        menuView = getChildAt(0);
        mainView = getChildAt(1);
    }

    /**
     * 这里设置触摸/拦截事件给DragViewHelper
     */
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        mHelper.processTouchEvent(event);
        return true;
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        return mHelper.shouldInterceptTouchEvent(ev);
    }

    /**
     * 设置computeScroll
     */
    @Override
    public void computeScroll() {
        if (mHelper.continueSettling(true)) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }
}
</code></pre><p>运行程序，就会看到和上面一样的效果啦。ViewDragHelper是最麻烦的一种，但是多写一写就好啦~</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-ViewDragHelper/" data-id="cjfx8xuff0003qqfyt83kb5w7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-View的滑动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-View的滑动/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-View的滑动/">Android-View的滑动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>滑动效果是如何产生的？</p>
</blockquote>
<p>滑动一个View从本质上来说就是移动一个View，改变其当前的坐标。所以，想要滑动一个View，就必须监听该View的触摸事件，并且根据事件的坐标，不断的改变View的坐标从而实现View的滑动。</p>
<h2 id="Android中的坐标体系"><a href="#Android中的坐标体系" class="headerlink" title="Android中的坐标体系"></a>Android中的坐标体系</h2><p>Android中的坐标体系分为两种：</p>
<ol>
<li>Android坐标系</li>
<li>视图坐标系</li>
</ol>
<blockquote>
<p>Android坐标系</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-0ea610d2436d0fe0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android坐标系"></p>
<p>从图中我们可以看的出来<strong>在Android坐标系中以屏幕的左上方作为坐标系的原点，从原点向右为X轴的正方向，向下为Y轴的正方向</strong>。在触控事件中使用<strong>getRawX()、getRawY()</strong>来获得Android坐标系的坐标</p>
<blockquote>
<p>视图坐标系</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-a6921068bc9cf072?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视图坐标系"></p>
<p>视图坐标系主要描述的是该View和该View在父视图中的位置关系，和Android坐标系一样，也是以原点右方为X正方向，以原点下方为Y轴正方向，不过这里不是以屏幕的左上角为原点，而是<strong>以父视图的左上角为原点</strong>。在触控事件中使用<strong>getX()、getY()</strong>来获得视图坐标系的坐标</p>
<h2 id="触控事件"><a href="#触控事件" class="headerlink" title="触控事件"></a>触控事件</h2><p>在上一篇文章中我们使用到了MotionEvent，这个就是触控事件的封装，首先看一下MotionEvent中封装的事件常量</p>
<ul>
<li>public static final int ACTION_DOWN = 0;    //单点触摸按下动作</li>
<li>public static final int ACTION_UP = 1;    //单点触摸离开动作</li>
<li>public static final int ACTION_MOVE = 2;    //单点触摸移动动作</li>
<li>public static final int ACTION_CANCEL = 3;    //触摸动作取消</li>
<li>public staiic final int ACTION_OUTSIDE = 4;    //触摸动作超出边界</li>
<li>public static final int ACTION_POINTER_DOWN = 5; //多点触摸按下动作</li>
<li>public static final int ACTION_POINTER_UP = 6; 多点离开动作</li>
</ul>
<p>通常情况下我们会在onTouchEvent(MotionEvent event)方法中通过event.getAction()来获取触控事件的类型。知道Android中的坐标系和触控事件之后我们就可以来实现View的滑动了</p>
<hr>
<h1 id="滑动实现"><a href="#滑动实现" class="headerlink" title="滑动实现"></a>滑动实现</h1><blockquote>
<p>实现滑动有好多种方法，但是其思想都是一样的。当触摸到View时，记录当前触摸点的坐标，然后当手指移动时，获取到相对于前一个点的偏移量，这样我们就可以通过这个偏移量来进行修改View的坐标，这样不断的重复，就能实现View的滑动</p>
</blockquote>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>我们自定义一个View，让他来跟随我们手指的移动来移动，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-82d4117c39eaf270.gif?imageMogr2/auto-orient/strip" alt=""></p>
<ul>
<li><strong>layout方法</strong></li>
</ul>
<p>我们知道在View进行绘制的时候会通过onLayout()方法来设置View的显示位置，这里我们通过修改View的left, top, right, bottom四个值来控制View的坐标</p>
<pre><code>public boolean onTouchEvent(MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            //记录触摸点的坐标
            lastX = x;
            lastY = y;
            break;
        case MotionEvent.ACTION_MOVE:
            //计算偏移量
            int offsetX = x - lastX;
            int offsetY = y - lastY;

            //在当前位置基础加上偏移量
            layout(
                    getLeft() + offsetX,
                    getTop() + offsetY,
                    getRight() + offsetX,
                    getBottom() + offsetY
            );
            break;
    }
    return true;
}
</code></pre><hr>
<ul>
<li><strong>offsetLeftAndRight()和offsetTopAndBottom</strong></li>
</ul>
<p>这个方法就是相当于系统提供的一个对左右、上下移动的API的封装，计算好偏移量后，调用方法即可：</p>
<pre><code>offsetLeftAndRight(offsetX);
offsetTopAndBottom(offsetY);
</code></pre><hr>
<ul>
<li><strong>LayoutParams</strong></li>
</ul>
<p>LayoutParams保存了View的布局参数，所以我们可以改变LayoutParams来动态的改变布局的位置来达到滑动的效果。在程序中使用getLayoutParams()来获取当前View的LayoutParams，这里就和上面一样，获取到偏移量后通过setLayoutParams来设置该View的LayoutParams：</p>
<pre><code>RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) getLayoutParams();
params.leftMargin = getLeft() + offsetX;
params.topMargin = getTop() + offsetY;
setLayoutParams(params);
</code></pre><p><strong>需要注意一点，通过getLayoutParams()获取LayoutParams的时候，要根据View的父布局的类型来设置，当然前提还要有一个父布局。还有就是我们可以使用ViewGroup.MarginLayoutParams，这样就不用考虑父布局是什么了</strong></p>
<hr>
<ul>
<li><strong>scrollTo、scrollBy</strong></li>
</ul>
<p>在View中，系统还提供了scrollTo、scrollBy两种方式来改变一个View的位置。</p>
<p>其中scrollTo表示移动到一个具体的坐标点，scrollBy表示移动的偏移量，其实在scrollBy内部也是调用的scrollTo。</p>
<p>和前面的方式一样，获取到偏移量后调用scrollBy来移动view，可是当我们运行程序，拖动View，发现View并没有移动！这是因为scrollTo、scrollBy方法移动的是View的内容，如果在ViewGroup中使用scrollTo、scrollBy的滑，那么移动的就是View了，但是如果在View中使用，那么移动的将是View里面的内容，比如TextView，那么移动的就是文本了。</p>
<p>所以通过上面的分析，我们把代码改为如下:</p>
<pre><code>((View)getParent()).scrollBy(offsetX, offsetY);
</code></pre><p>再次运行程序，我们会发现动是动了，但是在乱动。因为这里我们其实是在相反的方向移动（这里由于篇幅限制，感兴趣的同学自行查找一下资料），我们把偏移量改为负的之后就会发现滑动正常了。</p>
<hr>
<ul>
<li><strong>Scroller</strong></li>
</ul>
<p>首先来想一个场景：我们需要让一个Button向右面移动100个像素，如果我们用scrollTo/scrollBy的话，那么该View就会很突兀的移动到该点，没有过程，而Scroller则是可以实现平滑的过渡效果的</p>
<p>下面我们把上面跟随手指滑动的例子改一下，我们在松开手指后，View自动回到原点（屏幕左上角）。使用Scroller需要三个步骤</p>
<ol>
<li>初始化<ul>
<li>通过构造方法即可   Scroller mScroller = new Scroller(context);</li>
</ul>
</li>
<li>重写computeScroll()方法，实现滑动</li>
<li>startScroll()开启滑动</li>
</ol>
<p>代码如下：</p>
<pre><code>        case MotionEvent.ACTION_UP:
            View viewGroup = (View) getParent();
            mScroller.startScroll(
                    viewGroup.getScrollX(),
                    viewGroup.getScrollY(),
                    -viewGroup.getScrollX(),
                    -viewGroup.getScrollY()
            );
            invalidate();
            break;

  ----------------------------------------------------------------     

        @Overrid  
        public void computeScroll() {
            super.computeScroll();
            if (mScroller.computeScrollOffset()) {
            ((View) getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            invalidate();
    }
}
</code></pre><p>当我们手指抬起来的时候开启Scroller滑动，获取到当前view的移动距离，然后我们把需要移动的偏移量设置为相反数就ok，最后调用invalidate来通知重绘，从而调用computeScroll()方法。运行程序如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-2251dce7b4d1c1c7.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>现在就把这几种View的滑动都说完了，自己动手写一下，感触良多。</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-View的滑动/" data-id="cjfx8xufp0007qqfyeqnh0i72" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/">Python-学装饰器之前，有几个点要理解</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Python/Python-记学习对象可变性/">Python-记学习对象可变性</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义banner实现/">Android-自定义banner实现</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义View/">Android - 自定义View</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-各种情况下的『自动加载更多』/">Android-各种情况下的『自动加载更多』</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 王璐<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>