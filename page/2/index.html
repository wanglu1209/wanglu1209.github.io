<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>王璐的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="王璐的博客">
<meta property="og:url" content="http:/page/2/index.html">
<meta property="og:site_name" content="王璐的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王璐的博客">
  
    <link rel="alternate" href="/atom.xml" title="王璐的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">王璐的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http:"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android/Android-View的测量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-View的测量/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-View的测量/">Android View的测量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Android View的测量</p>
</blockquote>
<p>在绘制View之前，要对整个View进行测量，这个过程就在onMeasure()方法中进行的。</p>
<h4 id="测量的模式"><a href="#测量的模式" class="headerlink" title="测量的模式"></a>测量的模式</h4><ol>
<li>EXACTLY<ul>
<li>精确值模式，当控件的width和height设置为具体值或者match_parent时就是这个模式</li>
</ul>
</li>
<li>UNSPECIFIED<ul>
<li>这个属性不指定测量的模式，View想多大就多大</li>
</ul>
</li>
<li>AT_MOST<ul>
<li>最大值模式，当控件的width和height设置为wrap_context时就是这个模式，控件的大小随着子控件的大小而变化</li>
</ul>
</li>
</ol>
<p>其中View类<strong>默认的</strong>onMeasure()方法<strong>只支持EXACTLY模式</strong>，所以说如果不重写onMeasure()方法的话就只能使用EXACTLY模式。</p>
<p>一言不合上代码</p>
<pre><code>public CustomView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    setBackgroundColor(Color.BLUE);
} 
</code></pre><p>这里我只给当前自定义View设置了一个背景颜色，然后在XML中设置成wrap_content</p>
<pre><code>&lt;com.github.wanglu1209.CustomView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt; 
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1822424-15549d4c06f7dfbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>运行起来就是这样全屏的，下面我们还是这个例子，重写onMeasure()方法</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);

    int specMode, specSize = 0;
    int mWidth, mHeight;

    /**
     * Measure Width
     */
    specMode = MeasureSpec.getMode(widthMeasureSpec);
    switch (specMode){
        case MeasureSpec.AT_MOST:   //wrap_content
            specSize = 200;
            break;
        case MeasureSpec.EXACTLY:   //math_content 和 精确值
            specSize = MeasureSpec.getSize(widthMeasureSpec);
            break;
        case MeasureSpec.UNSPECIFIED:
            specSize = 400;
            break;
    }
    mWidth = specSize;

    /**
     * Measure Height
     */
    specMode = MeasureSpec.getMode(heightMeasureSpec);
    switch (specMode){
        case MeasureSpec.AT_MOST:   //wrap_content
            specSize = 200;
            break;
        case MeasureSpec.EXACTLY:   //math_content 和 精确值
            specSize = MeasureSpec.getSize(heightMeasureSpec);
            break;
        case MeasureSpec.UNSPECIFIED:
            specSize = 400;
            break;
    }
    mHeight = specSize;

    /**
     * 最后调用setMeasuredDimension进行赋值
     */
    setMeasuredDimension(mWidth, mHeight);
}
</code></pre><p>可以看到这里我们给wrap_content赋值200，我们XML代码不变还是wrap_content，运行一下程序</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-0e9fc7b558921b74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看的出来大小确实变成了200，通过这个小例子就可以对View的测量有一个不错的认识了，并没有什么高深莫测的东西，一步一步来。</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-View的测量/" data-id="cjfx8rwzb0005i4fysjgk1ifp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-Paint高级-PorterDuffXfermode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-Paint高级-PorterDuffXfermode/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-Paint高级-PorterDuffXfermode/">Android-Paint高级-PorterDuffXfermode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实在前面的文章中也都用到了画笔（Paint），了解了一些常用的属性，比如抗锯齿，带边框，空心，宽度等，这些都是最基本的属性，下面来说一个高级属性『PorterDuffXfermode』</p>
<h2 id="PorterDuffXfermode"><a href="#PorterDuffXfermode" class="headerlink" title="PorterDuffXfermode"></a>PorterDuffXfermode</h2><p>首先看一张图</p>
<p><img src="http://pic4.zhongsou.com/img?id=522984b61da05c120fd" alt=""></p>
<p>PoerterDuffXfermode设置的是两个图层交集区域的显示方式，其中dst是先画的图形，src是后画的图形。</p>
<p>这里列举了16种，当然有的都不怎么经常使用，最常用的就是DST_IN、SRC_IN来将矩形图片变成圆角图片或者圆形图片了。下面就来进行一个实例CircleImageView（好久之前就看过鸿神的这个View，一直不怎么理解，书看到这一章节就忽然想起来了，自己重新写一遍），完成图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-7c5ffb9fe73e0d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="分如下几步"><a href="#分如下几步" class="headerlink" title="分如下几步"></a>分如下几步</h4><ol>
<li>获得图片</li>
<li>测量宽高</li>
<li>创建画布</li>
<li>画一个圆</li>
<li>使用PerterDuffXfermode来控制下一个图片和刚才的圆交集</li>
<li>画图片</li>
<li>完事</li>
</ol>
<p>首先我们在构造函数中获得图片：</p>
<pre><code>public CircleImageView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleImageView, defStyleAttr, 0);
    try {
        mBitmap = BitmapFactory.decodeResource(getResources(), a.getResourceId(R.styleable.CircleImageView_src, -1));
        if (mBitmap == null) {
            throw new RuntimeException(&quot;src Null!&quot;);
        }
    } finally {
        a.recycle();
    }
}
</code></pre><p>然后我们在onMeasure()中控制图片的宽高</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    mWidth = measureWidthAndHeight(MeasureSpec.getSize(widthMeasureSpec));
    mHeight = measureWidthAndHeight(MeasureSpec.getSize(heightMeasureSpec));
    setMeasuredDimension(mWidth, mHeight);
}

private int measureWidthAndHeight(int size) {
    int mode = MeasureSpec.getMode(size);
    switch (mode) {
        case MeasureSpec.UNSPECIFIED:
        case MeasureSpec.AT_MOST:
            return 200;
        case MeasureSpec.EXACTLY:
        default:
            return size;
    }
}
</code></pre><p>这里我们给wrap_content设置了一个200的值，然后我们在onDraw()方法中完成我们剩下的工作：</p>
<pre><code>protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.drawBitmap(createBitmap(), 0, 0, null);
}

private Bitmap createBitmap() {
    /**
     * 获取宽高最小值,重新生成一个Bitmap
     */
    int min = Math.min(mHeight, mWidth);
    mBitmap = Bitmap.createScaledBitmap(mBitmap, min, min, false);

    /**
     * 根据原有的Bitmap再生成一个Bitmap,当做Canvas的参数
     * 如果在Canvas的构造中带入一个Bitmap的话,那么后续在画布上画的东西就等于在Bitmap上画的
     */
    Bitmap b = Bitmap.createBitmap(min, min, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(b);

    /**
     * 初始化画笔,设置抗锯齿
     */
    mPaint = new Paint();
    mPaint.setAntiAlias(true);

    /**
     * 首先画一个圆,和画布一样大
     */
    canvas.drawCircle(min / 2, min / 2, min / 2, mPaint);

    /**
     * 设置PoerterDuffXfermode参数,使后面画的和前面画的交集
     * 这样就等于在一个圆上画我们的图片,所以看到的就是一个圆形的图片了
     */
    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
    canvas.drawBitmap(mBitmap, 0, 0, mPaint);
    return b;
}
</code></pre><p>这样就好啦，运行程序就可以看到我们开始的效果啦~</p>
<p><strong>感谢鸿洋大神</strong></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/42094215" target="_blank" rel="noopener">原文地址</a></p>
<hr>
<h2 id="第二个实例-刮刮卡"><a href="#第二个实例-刮刮卡" class="headerlink" title="第二个实例  刮刮卡"></a>第二个实例  刮刮卡</h2><p>相信大家都玩过刮刮卡，记得没错好像是支付宝也弄过这个效果（好像是在支付成功后）</p>
<p>刮刮卡有两个图层，上面一层和下面的图片，上面的主要用来被刮掉，在初始状态下，上面的图层会掩盖住下面的图层，当用手刮上面的图层时，下面的会慢慢显示出来，这就需要用到DST_IN了。效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-11f99be96020f64f.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h4 id="分如下几步-1"><a href="#分如下几步-1" class="headerlink" title="分如下几步"></a>分如下几步</h4><ol>
<li>初始化Paint和图片等</li>
<li>在onDraw()方法中绘制两个图片，首先绘制背景图，然后绘制遮罩层</li>
<li>在onTouchEvent()方法中绘制路径</li>
<li>使用DST_IN模式绘制在上图层就ok</li>
</ol>
<p>首先初始化，代码如下：</p>
<pre><code>private void init() {
    mPaint = new Paint();
    /**
     * 设置画笔透明度为0,设置PoerterDuffXfermode为DST_IN模式
     */
    mPaint.setAlpha(0);
    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
    mPaint.setStyle(Paint.Style.STROKE);
    mPaint.setStrokeJoin(Paint.Join.ROUND); //设置画笔图形样式
    mPaint.setStrokeCap(Paint.Cap.ROUND);   //设置画笔转弯连接处的风格
    mPaint.setStrokeWidth(50);  //设置宽度

    mPath = new Path();
    /**
     * 获取背景图片
     */
    mBgBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.a1);

    /**
     * 创建遮罩层Bitmap和背景图片一样大小,画上灰色
     */
    mFgBitmap = Bitmap.createBitmap(mBgBitmap.getWidth(), mBgBitmap.getHeight(), Bitmap.Config.ARGB_8888);
    mCanvas = new Canvas(mFgBitmap);
    mCanvas.drawColor(Color.GRAY);
}
</code></pre><p>然后绘制两个图层：</p>
<pre><code>protected void onDraw(Canvas canvas) {
    /**
     * 首先绘制背景图,然后绘制遮罩层,这样遮罩层才会在背景图上面
     */
    canvas.drawBitmap(mBgBitmap, 0, 0, null);
    canvas.drawBitmap(mFgBitmap, 0, 0, null);
}
</code></pre><p>最后在onTouchEvent()方法中绘制路径：</p>
<pre><code>public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        /**
         * 重置一下路径,移动到该点
         */
        case MotionEvent.ACTION_DOWN:
            mPath.reset();
            mPath.moveTo(event.getX(), event.getY());
            break;
        /**
         * 路径的点
         */
        case MotionEvent.ACTION_MOVE:
            mPath.lineTo(event.getX(), event.getY());
            break;
    }

    /**
     * 绘制路径,其实是在mFgBitmap上绘制
     * 并且由于DST_IN模式,取交集,透明度为0,所以就能实现刮刮卡的效果
     */
    mCanvas.drawPath(mPath, mPaint);

    /**
     * 通知重绘
     */
    invalidate();
    return true;
}
</code></pre><p>这样一个刮刮卡的效果就完成了，是不是很简单。</p>
<p><strong>需要注意的一点：在使用PorterDuffXfermode时，最好把硬件加速关闭，因为有的模式不支持硬件加速</strong></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-Paint高级-PorterDuffXfermode/" data-id="cjfx8rwz40003i4fy3dlnb01b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-触摸事件的分发和处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-触摸事件的分发和处理/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-触摸事件的分发和处理/">Android-触摸事件的分发和处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="首先想要了解事件的分发和处理，就要先了解什么是触摸事件"><a href="#首先想要了解事件的分发和处理，就要先了解什么是触摸事件" class="headerlink" title="首先想要了解事件的分发和处理，就要先了解什么是触摸事件"></a>首先想要了解事件的分发和处理，就要先了解什么是触摸事件</h3><hr>
<blockquote>
<p>什么是触摸事件？</p>
</blockquote>
<p>顾名思义，触摸事件就是我们触碰屏幕之后产生的事件，一般触碰到屏幕之后会触发两个或者三个事件</p>
<ol>
<li>按下        Action_Down</li>
<li>如果滑动    Action_Move</li>
<li>抬起        Action_Up</li>
</ol>
<p>这些事件封装成了一个类『MotionEvent』，如果重写onTouchEvent()方法，该方法的参数就是一个MotionEvent对象。在MotionEvent里不止有这几个事件，还可以取出当前触摸的坐标点等等。</p>
<hr>
<p>当然，这只是在一个View中，但是我们知道，Android的View结构是树形的，View可以放在一个ViewGroup当中，然后这个ViewGroup当中又嵌套一个ViewGroup。所以当我触摸屏幕的时候到底是谁来执行这个事件？这样就引出了『事件拦截』</p>
<p><strong>我们想象一下场景</strong></p>
<p>一个总经理，一个技术经理，然后干活的你。总经理把任务布置给技术经理，然后技术经理把任务安排给了你。过了一会你把任务完成，交给技术经理，技术经理觉的不错，就交给了总经理，这样这个任务就完成了</p>
<p>了解了这个流程之后，对于事件拦截也就理解了小半了，下面来一个实例看一下</p>
<hr>
<p>首先我们自定义两个ViewGroup和一个View分别对应一个总经理一个技术经理和一个干活的。</p>
<p>在两个ViewGroup中我们主要重写三个方法</p>
<ol>
<li>dispatchTouchEvent()</li>
<li>onInterceptTouchEvent()</li>
<li>onTouchEvent()</li>
</ol>
<p>然后在View中重写两个方法</p>
<ol>
<li>dispatchTouchEvent()</li>
<li>onTouchEvent()</li>
</ol>
<p>然后我们在这几个方法中什么都不改，只是在里面打印Log日志来看一下执行的顺序。</p>
<p>XML布局如下：</p>
<pre><code>&lt;com.github.wanglu1209.androidqunyingzhuan.ViewGroupA
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;com.github.wanglu1209.androidqunyingzhuan.ViewGroupB
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;com.github.wanglu1209.androidqunyingzhuan.MyView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;/com.github.wanglu1209.androidqunyingzhuan.ViewGroupB&gt;

&lt;/com.github.wanglu1209.androidqunyingzhuan.ViewGroupA&gt;
</code></pre><p>现在运行程序，查看Log，如下：</p>
<blockquote>
<p>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupB dispatchTouchEvent<br>ViewGroupB onInterceptTouchEvent<br>View dispatchTouchEvent<br>View onTouchEvent<br>ViewGroupB onTouchEvent<br>ViewGroupA onTouchEvent</p>
</blockquote>
<p>可以看的出来，正常情况下事件的传递顺序为：</p>
<p>ViewGroupA -&gt; ViewGroupB -&gt; View</p>
<p>事件的处理顺序为：</p>
<p>View -&gt; ViewGroupB -&gt; ViewGroupA</p>
<p>其中事件传递的返回值：</p>
<ol>
<li>True 拦截，不继续传递</li>
<li>False 不拦截，传递</li>
</ol>
<p>事件处理的返回值：</p>
<ol>
<li>True 处理完毕，不交给上级</li>
<li>False 交给上级</li>
</ol>
<blockquote>
<p>事件分发</p>
</blockquote>
<p><strong>现在我们给代码做一些改动，把ViewGroupA的onInterceptTouchEvent()的返回值改为True，查看一下log</strong></p>
<p>log如下：</p>
<blockquote>
<p>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupA onTouchEvent</p>
</blockquote>
<p>这里我们直接在最外侧的ViewGroupA中把事件拦截了下来，所以后面的ViewGroupB和View都没有接收到触摸事件。如果我们在ViewGroupB中拦截事件，那么log如下；</p>
<blockquote>
<p>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupB dispatchTouchEvent<br>ViewGroupB onInterceptTouchEvent<br>ViewGroupB onTouchEvent<br>ViewGroupA onTouchEvent</p>
</blockquote>
<p>这样把Log打印出来就对事件的拦截和传递有了一个清晰的认识，下面来看一下事件的处理</p>
<hr>
<blockquote>
<p>事件处理</p>
</blockquote>
<p>开始的时候我们说过，当你完成了任务之后会像你的项目经理报告，需要上级的确认，所以你的事件处理返回false，如果有一天你不干了，那么你也就不用给上级报告了，返回了true，来看一下log</p>
<blockquote>
<p>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupB dispatchTouchEvent<br>ViewGroupB onInterceptTouchEvent<br>View dispatchTouchEvent<br>View onTouchEvent<br>ViewGroupA dispatchTouchEvent<br>ViewGroupA onInterceptTouchEvent<br>ViewGroupB dispatchTouchEvent<br>ViewGroupB onInterceptTouchEvent<br>View dispatchTouchEvent<br>View onTouchEvent</p>
</blockquote>
<p>事件传递和以前一样依次的传递下来，但是处理事件到View这里就结束了，没有向上级传递，如果给ViewGroupB的onTouchEvent的返回值true，那么事件处理到ViewGroupB就结束了。</p>
<p>这样一来，事件的分发和处理就了解了</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-触摸事件的分发和处理/" data-id="cjfx8rwzy000ci4fyoo0v49nu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义控件PickerView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-自定义控件PickerView/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-自定义控件PickerView/">Android-自定义控件PickerView</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间在公司总是有需求『滚动的选择器』，那时候总是用别人写好的来用，感觉心里不是很舒服，最近有时间了自己来写一写，上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-6d1e3f570799130a.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>首先分析一下需求：</p>
<ol>
<li>可以滑动</li>
<li>滑到两条线里的数据变色</li>
<li>滑动完成后必须要把选中的数据放到中间</li>
</ol>
<h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><p>首先说到滑动而且还是自定义的View，我们就会想到各种『scrollBy/scrollTo』等，但是这里有个更简单的方法就是<strong>继承自ScrollView</strong>，这样就简单了不少，并且还有滚动的监听『只不过少了一个停止滑动的状态』，然而对于这个需求，我们只需要创建一个ViewGroup来放入数据（也就是很多TextView），然后addView()就OK，代码如下：</p>
<pre><code>/**
 * 初始化数据,首先添加Group
 */
mTextGroup = new LinearLayout(context);
mTextGroup.setOrientation(LinearLayout.VERTICAL);
mTextGroup.setGravity(Gravity.CENTER);
addView(mTextGroup);


/**
 * 由于我们需要给自身的数据在选中的框里显示
 * 所以这里需要添加前面和后面的空数据
 */
mTextGroup.addView(createTextView(&quot;&quot;));
for (int i = 0; i &lt; mData.size(); i++) {
    mTextGroup.addView(createTextView(&quot;&quot; + mData.get(i)));
}
mTextGroup.addView(createTextView(&quot;&quot;));

------------------------------------------------------------

/**
 * 动态创建TextView
 */
private TextView createTextView(String s) {
    TextView tv = new TextView(context);
    tv.setText(s);
    tv.setTextColor(getResources().getColor(android.R.color.darker_gray));
    tv.setTextSize(mTextSize);
    LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, mTextHeight);

    params.bottomMargin = mTextHeight / 2;
    params.topMargin = mTextHeight / 2;
    tv.setLayoutParams(params);
    return tv;
}
</code></pre><p>可以看到我们在数据的前后都加了两条空数据，因为这里需要在滑动到底部或者顶部的时候确保第一条或者最后一条数据是在我们的两条线之内，这样运行一下程序就会发现我们的数据已经可以滑动了，只不过这个时候还没有中间的两条线。这里需要思考一下，如果我们添加两条线上去的话，滑动的时候线也会跟着滑动，所以这个时候就想到了背景，我们自己来画一个背景。代码如下：</p>
<pre><code>/**
 * 设置背景,这里选择画一个,两条线
 */
setBackground(new Drawable() {
    @Override
    public void draw(Canvas canvas) {
        /**
         * 这里把两条线之间的距离设置为了两个TextView的高度
         */
        canvas.drawLine(
                mWidth * 0.1f,
                mHeight / 2 - mTextHeight,
                mWidth * 0.9f,
                mHeight / 2 - mTextHeight,
                mLinePaint
        );
        canvas.drawLine(
                mWidth * 0.1f,
                mHeight / 2 + mTextHeight,
                mWidth * 0.9f,
                mHeight / 2 + mTextHeight,
                mLinePaint
        );
    }

    @Override
    public void setAlpha(int i) {

    }

    @Override
    public void setColorFilter(ColorFilter colorFilter) {

    }

    @Override
    public int getOpacity() {
        return 0;
    }
});
</code></pre><p>这时候我们的背景和数据都弄好了</p>
<h3 id="在线内的数据变颜色"><a href="#在线内的数据变颜色" class="headerlink" title="在线内的数据变颜色"></a>在线内的数据变颜色</h3><p>先考虑一下，因为我们使用的是TextView，所以我们直接就可以设置TextView的字体颜色。很简单，我们在onScrollChanged()方法中用小学除法来算一下当前滚动到了哪个TextView『也就是position』，我们就把哪个改变颜色，代码如下：</p>
<pre><code>/**
 * ScrollView的滑动事件监听
 */
@Override
protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);

    /**
     * 计算出当前在两条线里的position
     */
    position = (t + mTextHeight) / (mTextHeight * 2);
    /**
     * 因为此方法会在滑动的时候不停的调用,所以这里设置一个临时的变量来控制
     */
    if (tempPosition != position) {
        int size = mTextGroup.getChildCount();
        for (int i = 0; i &lt; size; i++) {
            TextView tv = (TextView) mTextGroup.getChildAt(i);
            /**
             * 因为我们在数据开头添加了一个空的数据,所以这里position要+1
             */
            if (position + 1 == i) {
                tv.setTextColor(getResources().
                        getColor(android.R.color.holo_blue_dark));
            } else {
                tv.setTextColor(getResources().
                        getColor(android.R.color.darker_gray));
            }
        }
    }
    tempPosition = position;
}
</code></pre><h3 id="滑动结束后把当前数据放在中间（其实我不知道怎么表达了）"><a href="#滑动结束后把当前数据放在中间（其实我不知道怎么表达了）" class="headerlink" title="滑动结束后把当前数据放在中间（其实我不知道怎么表达了）"></a>滑动结束后把当前数据放在中间（其实我不知道怎么表达了）</h3><p>ScrollView没有滑动结束的监听，所以我们只好取巧来弄一个。我们在手指离开屏幕的30ms后来判断当前的scrollY和离开屏幕时候的scrollY是否一样，一样则认定是滑动结束了，如果不一样，我们强行给弄成一样的来结束滑动</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent ev) {
    /**
     * 因为ScrollView没有停止滑动的监听,所以这里取巧
     * 在手指离开屏幕的30ms后判断是否和原来的scrollY一样
     * 如果一样则进入,如果不一样则设置为一样
     */
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        scrollY = getScrollY();
        postDelayed(new Runnable() {
            @Override
            public void run() {
                if (scrollY == getScrollY()) {
                    /**
                     * 获得每次松手后scrollY相对于TextView高度的偏移量
                     */
                    int offset = scrollY % (mTextHeight * 2);

                    /**
                     * 如果偏移量大于TextView高度的一半
                     * 则进入到下一个
                     */
                    if (offset &gt; mTextHeight) {
                        smoothScrollTo(0, scrollY - offset + (mTextHeight * 2));
                    } else {
                        smoothScrollTo(0, scrollY - offset);
                    }
                } else {
                    scrollY = getScrollY();
                    post(this);
                }
            }
        }, 30);
    }
    return super.onTouchEvent(ev);
}
</code></pre><p>到这里就结束了，其实还是蛮简单的，只不过功能甚少，只能实现基本的选择数据，所以我起名为PickerView，当然以后还会对这个项目进行维护，已经上传github，地址<a href="https://github.com/wanglu1209/PickerView" target="_blank" rel="noopener">PickerView</a>，欢迎大家来star或者提bug</p>
<hr>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><p>感谢wangjiegulu的WheelView给的启发，放上地址</p>
<p><a href="https://github.com/wangjiegulu/WheelView" target="_blank" rel="noopener">WheelView</a></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-自定义控件PickerView/" data-id="cjfx8rx00000di4fye4hafayk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-Android性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-Android性能优化/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-Android性能优化/">Android-Android性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>其实关于性能优化这个我也只是学到个皮毛，我是按照书上说的加上自己理解的来写，<strong>如果有不对的地方，请指正，我也是个菜鸟。谢谢</strong></p>
</blockquote>
<p>Android性能的优化主要分为两点</p>
<ol>
<li>布局优化</li>
<li>内存优化</li>
</ol>
<h2 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h2><p>首先来看一下布局优化，系统在渲染UI的时候会消耗大量的资源，所以，对布局的优化就显得尤为重要</p>
<h4 id="避免Overdraw"><a href="#避免Overdraw" class="headerlink" title="避免Overdraw"></a>避免Overdraw</h4><p>也就是避免过度的绘制，过度的绘制会浪费更多的资源，<strong>举个例子，Android系统会默认绘制Activity的背景，这时候我们再设置一个背景，这样默认的背景就属于过度绘制了，</strong>在『开发者工具』中有一个『调试GPU过度绘制』的选项，我们打开就可以通过颜色来判断过度绘制的次数，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-0cf8e3b06aa8b4ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>所以说我们尽可能的<strong>增大蓝色区域，减少红色区域</strong></p>
<h4 id="优化布局层级"><a href="#优化布局层级" class="headerlink" title="优化布局层级"></a>优化布局层级</h4><p>在Android系统中，系统对View进行测量、布局、绘制的时候，都是通过对View树的遍历来进行的，所以说<strong>一个布局的层级太多，就会严重影响测量、布局、绘制的速度，所以要降低View树的高度，Google在文档中建议布局的层级不超过10层，所以还要避免嵌套没有用的布局</strong></p>
<h4 id="使用include标签"><a href="#使用include标签" class="headerlink" title="使用include标签"></a>使用include标签</h4><p>相信大家都会在项目的时候遇到toolbar，或者一个UI在多个界面使用的问题，遇到这种问题的时候我们一般都会用include（毕竟郭神『第一行代码』教的好），这样就减少了代码冗余，而且还利于后期更改</p>
<h4 id="使用ViewStub实现View的延时加载"><a href="#使用ViewStub实现View的延时加载" class="headerlink" title="使用ViewStub实现View的延时加载"></a>使用ViewStub实现View的延时加载</h4><p>ViewStub标签和View.GONE的方式差不多，但是ViewStub只会在显示的时候去渲染，而GONE在初始化的时候就已经渲染完毕了，所以相比来说ViewStub的效率更高。下面来通过代码使用一下ViewStub</p>
<p>首先我们定义一个布局文件</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/tv&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>这里面只放了一个TextView，然后我们在自己的布局中通过ViewStub来引用他</p>
<pre><code>&lt;Button
   android:id=&quot;@+id/btn&quot;
   android:layout_width=&quot;wrap_content&quot;
   android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;ViewStub
   android:id=&quot;@+id/vs&quot;
   android:layout_width=&quot;wrap_content&quot;
   android:layout_height=&quot;wrap_content&quot;
   android:layout=&quot;@layout/view_stub&quot;/&gt;
</code></pre><p>这里的逻辑是点击按钮然后出现ViewStub引用的布局（也就是我们上面写的那个布局文件）</p>
<pre><code>findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        ViewStub vs = (ViewStub) findViewById(R.id.vs);
        View vsView = vs.inflate();
        TextView tv = (TextView) vsView.findViewById(R.id.tv);
        tv.setText(&quot;hahaha&quot;);

    }
});
</code></pre><p>这里想要把ViewStub引用的布局显示出来有两种办法，一种是ViewStub.setVisibility();另一种就是ViewStub.inflate();这两种方法的区别就是inflate()能返回引用的布局，然后可以通过这个布局来找到里面的子View来进行操作</p>
<p>运行程序点击按钮，就可以看到TextView已经显示出来了，并且已经赋值『hahaha』</p>
<h4 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h4><p>这个工具可以显示我们的布局，但是只可以在模拟器和工厂的Demo机上用，不过Google的大神提供了一个开源的项目ViewServer，有兴趣的可以看一下，地址：<a href="https://github.com/romainguy/ViewServer" target="_blank" rel="noopener">ViewServer</a></p>
<p>这个就不过多阐述了，有兴趣的可以自行查看一下相关的资料</p>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>我们都知道，最近Android的厂商就是在拼配置，其中我们最关注的就是内存几个G，但是Android手机有的内存很大，但是很卡，这是因为有的手机软件在手机内存低的情况下不能被杀死，也就是我们说的『防杀』</p>
<p>我们知道内存一般分为这几个部分</p>
<ul>
<li>寄存器</li>
<li>栈</li>
<li>堆</li>
<li>静态存储区</li>
<li>常量池</li>
</ul>
<p>其中寄存器运算速度最快，但是我们在程序里无法控制</p>
<p>栈里存放基本数据类型</p>
<p>堆里存放对象和数组，在堆中的一般由Java的GC还管理</p>
<p>静态存储区在固定的位置存放应用程序中运行时一直存在的数据，Java专门划分了一个区域来管理静态变量</p>
<p>常量池就是该类型所使用到的常量的集合</p>
<h4 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h4><p>我们都知道在Android中是造成OOM的最大威胁，因为它占用的内存特别多，所以我们应该：</p>
<ul>
<li>使用适当分辨率大小的图片<ul>
<li>由于Android在做适配的时候会对不同分辨率的文件夹下的图片来进行缩放适配，如果图片的分辨率与资源分辨率不匹配的话就会导致消耗更多的资源</li>
</ul>
</li>
<li>使用缓存<ul>
<li>一般有内存缓存和硬盘缓存</li>
</ul>
</li>
</ul>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul>
<li>对常量使用static</li>
<li>使用静态方法，静态方法比普通方法提高15%左右的访问速度</li>
<li>减少没有必要的成员变量，如果能定义成局部变量就最好定义成局部变量</li>
<li>减少不必要的对象</li>
<li>少用枚举、迭代器</li>
<li>对Cursor、Receiver、File等对象，要注意回收和取消注册</li>
<li>使用SurfaceView来代替View进行大量并且频繁的绘图操作</li>
<li>尽量使用视图缓存，不是每次都执行inflate()来解析视图</li>
<li>避免使用反射</li>
<li>使用RenderScript、OpenGL来进行非常复杂的绘图操作</li>
</ul>
<p>以上就是对Android性能优化的一些点，如果你用AndroidStudio的话，AndroidStudio提供了一个内存监视的工具，还是很好用的，如果你没用AndroidStudio，那么我建议你使用AndroidStudio~</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-Android性能优化/" data-id="cjfx8rwz20002i4fy3hhpdyb7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/hello-world/" class="article-date">
  <time datetime="2018-04-13T00:19:02.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/hello-world/" data-id="cjfx8rwxx0000i4fymqghe4wx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/">Python-学装饰器之前，有几个点要理解</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Python/Python-记学习对象可变性/">Python-记学习对象可变性</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义banner实现/">Android-自定义banner实现</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义View/">Android - 自定义View</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义ViewGroup/">自定义ViewGroup</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 王璐<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>