<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>王璐的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="王璐的博客">
<meta property="og:url" content="http:/index.html">
<meta property="og:site_name" content="王璐的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王璐的博客">
  
    <link rel="alternate" href="/atom.xml" title="王璐的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">王璐的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http:"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Python/Python-学装饰器之前，有几个点要理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/" class="article-date">
  <time datetime="2018-04-13T00:50:44.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/">Python-学装饰器之前，有几个点要理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>要不这样吧，如果编程语言里有个地方你弄不明白，而正好又有个人用了这个功能，那就开枪把他打死，这比学习新特性要容易些，然后过不了多久，那些活下来的程序员就会开始用0.9.6版本的Python，而且他们只需要使用这个版本中易于理解的小部分就好了（眨眼）。                  - Tim Peters</p>
</blockquote>
<p>首先推荐一波和朋友一起弄的壁纸下载，爬取了各大网站的壁纸，总有你喜欢的类型。<a href="http://wp.d2collection.com/" target="_blank" rel="noopener">http://wp.d2collection.com/</a></p>
<p>众所周知，Python里装饰器是一个很重要并且很牛X的功能，他可以在不改变原函数的功能和结构的基础上增加新功能。</p>
<p>但是想要理解装饰器还是有很多知识点的：</p>
<ul>
<li>导入时、运行时</li>
<li>闭包与变量的作用域</li>
<li>nonlocal</li>
</ul>
<p>一般我们的装饰器都是在另外的一个文件里写的，类似xxx_deco。</p>
<p>当我们在别的文件中引入进来并且在自己的函数上定义时，装饰器就<strong>立即运行</strong>了。（当然不是说代码刚写就运行了+_+）</p>
<p>用《流畅的Python》中的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running register(&lt;function f1 at 0x10373d730&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10373d7b8&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x10373d730&gt;, &lt;function f2 at 0x10373d7b8&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure>
<p>从结果我们可以证实刚才的话，在装饰后，就已经运行了。</p>
<p>下面我们来讨论变量的问题，众所周知，一个函数内部的变量在函数执行结束后就被销毁了。那么我们看一个小例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>这是一个利用闭包实现的求平均数的方法，导入运行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> average <span class="keyword">import</span> make_averager</span><br><span class="line">In[<span class="number">3</span>]: avg = make_averager()</span><br><span class="line">In[<span class="number">4</span>]: avg(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">10.0</span></span><br><span class="line">In[<span class="number">5</span>]: avg(<span class="number">11</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">10.5</span></span><br><span class="line">In[<span class="number">6</span>]: avg(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">11.0</span></span><br></pre></td></tr></table></figure>
<p>这里爱思考的盆友会看出来，每次值都被记录了下来，我当时看到这里的时候在想，这不是坑爹么！谁说局部变量执行完就销毁的(╯‵□′)╯︵┻━┻</p>
<p>跑回去看了一下闭包的解释：<strong>：闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</strong></p>
<p>闭包延伸了变量的作用域，还起了个名字叫自由变量。所以上面的series就是一个自由变量。<strong>自由变量是指在本地作用域中绑定的变量</strong>，所以这个series没有被释放掉并且一直可以用。</p>
<p>那么这个时候再来看，如果我想统计有多少个数字呢？代码增加如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>运行如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> average <span class="keyword">import</span> make_averager</span><br><span class="line">In[<span class="number">3</span>]: avg = make_averager()</span><br><span class="line">In[<span class="number">4</span>]: avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/WangLu/.pyenv/versions/3.5.2/lib/python3.5/site-packages/IPython/core/interactiveshell.py"</span>, line <span class="number">2862</span>, <span class="keyword">in</span> run_code</span><br><span class="line">    exec(code_obj, self.user_global_ns, self.user_ns)</span><br><span class="line">  File <span class="string">"&lt;ipython-input-4-2b3d43cb065d&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    avg(<span class="number">10</span>)</span><br><span class="line">  File <span class="string">"/Users/WangLu/Study/FluentPython/average.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> averager</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>报错了，在定义变量之前应用了变量。这跟刚才说的不一致。</p>
<p>在Python中，数字、元组等不可变类型是只读的，想要重新赋值就要重新创建变量，在刚才的例子中，如果重新创建变量的话那就不是自由变量了，没有自由变量的闭包还是闭包么？所以在Python3中引入了<strong>nonlocal</strong>声明，被nonlocal声明的变量为自由变量，闭包中的数据就会更新。</p>
<p>所以，代码改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    series = []</span><br><span class="line">    count = 0</span><br><span class="line"></span><br><span class="line">    def averager(new_value):</span><br><span class="line">        nonlocal count</span><br><span class="line">        count += 1</span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        return total / len(series)</span><br><span class="line"></span><br><span class="line">    return averager</span><br></pre></td></tr></table></figure>
<p>如果是Python2的话，就需要把变量设置为可变的如list等</p>
<p>至此，我们就可以来实现装饰器了，在每次调用的时候输出 哈哈 + 方法名 + 结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha_deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(*args)</span>:</span></span><br><span class="line">        result = func(*args)</span><br><span class="line">        print(<span class="string">'哈哈 -&gt; &#123;&#125;，结果为：&#123;&#125;'</span>.format(func.__name__, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> haha</span><br></pre></td></tr></table></figure>
<p>调用结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> haha_deco <span class="keyword">import</span> haha_deco</span><br><span class="line">In[<span class="number">3</span>]: @haha_deco</span><br><span class="line">  ...: <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(n)</span>:</span></span><br><span class="line">  ...:     <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * demo(n<span class="number">-1</span>)</span><br><span class="line">  ...: </span><br><span class="line">In[<span class="number">4</span>]: demo(<span class="number">5</span>)</span><br><span class="line">哈哈 -&gt; demo，结果为：1</span><br><span class="line">哈哈 -&gt; demo，结果为：2</span><br><span class="line">哈哈 -&gt; demo，结果为：6</span><br><span class="line">哈哈 -&gt; demo，结果为：24</span><br><span class="line">哈哈 -&gt; demo，结果为：120</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">120</span></span><br></pre></td></tr></table></figure>
<p>我觉得想要理解装饰器，这几个点是应该会的。</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><h4 id="爱生活，爱小丽"><a href="#爱生活，爱小丽" class="headerlink" title="爱生活，爱小丽"></a>爱生活，爱小丽</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/" data-id="cjfx8rx01000ei4fyoakuusme" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python/Python-记学习对象可变性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Python/Python-记学习对象可变性/" class="article-date">
  <time datetime="2018-04-13T00:50:17.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Python/Python-记学习对象可变性/">Python-记学习对象可变性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在刚学Python的时候就知道元组是不可变的，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: id(t)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">4457650000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: t += (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: id(t)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">4456501496</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: t</span><br><span class="line">Out[<span class="number">5</span>]: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>当我们想要改变元组的时候他会新建一个对象来存储值，但是当我们的元组里有一个可变的对象呢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: t1 = ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], )</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: t1[<span class="number">0</span>].append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: t1</span><br><span class="line">Out[<span class="number">10</span>]: ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],)</span><br></pre></td></tr></table></figure>
<p>其实元组保存的只是对象的引用，如果元组里的元素可变那么元素就是可变的。这里说的不可变只是元组保存的引用不变</p>
<p>在说一下深拷贝、浅拷贝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: l1 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: l2 = list(l1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: l2</span><br><span class="line">Out[<span class="number">13</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: l2[<span class="number">1</span>].append(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: l2</span><br><span class="line">Out[<span class="number">15</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: l1</span><br><span class="line">Out[<span class="number">16</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: l1[<span class="number">-1</span>] += (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: l1</span><br><span class="line">Out[<span class="number">19</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: l2</span><br><span class="line">Out[<span class="number">20</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>
<p>list()方法默认做的是浅拷贝。浅拷贝就是只复制最外层的容器，复制出来容器里的元素仍为源容器中元素的引用。即<strong>l2的元素引用还是指向l1的</strong>，所以当l2[1]更改了的时候l1[1]也更改了。但是由于元组是不可变元素，所以当更改他的时候会新创建一个元组对象，所以l1和l2中的互不干扰</p>
<p>而深拷贝则不共享引用，全部重新创建新的引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: l3 = copy.deepcopy(l1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: l3</span><br><span class="line">Out[<span class="number">23</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: l1</span><br><span class="line">Out[<span class="number">24</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: l1[<span class="number">1</span>].append(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: l1</span><br><span class="line">Out[<span class="number">26</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">200</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: l3</span><br><span class="line">Out[<span class="number">28</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br></pre></td></tr></table></figure>
<p>接下来说方法形参问题，都知道形参是一个实参的引用。那么这个时候传不可变对象还好。如果传可变参的话，那么方法做的更改就会关系到方法外</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    ...:     a += b</span><br><span class="line">    ...:     <span class="keyword">return</span> a</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: y = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: f(x, y)</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: x</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>所以，尽量不要传递一个可变的对象给函数，除非你想这么做</p>
<p>同理，函数的默认参也不要是一个可变对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: bus1 = HauntedBus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="string">'Alice'</span>, <span class="string">'Bill'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: bus1.pick(<span class="string">'Charlie'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: bus1.drop(<span class="string">'Alice'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">36</span>]: [<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: bus2 = HauntedBus()</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: bus2.passengers</span><br><span class="line">Out[<span class="number">39</span>]: [<span class="string">'Carrie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: bus3 = HauntedBus()</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: bus3.passengers</span><br><span class="line">Out[<span class="number">41</span>]: [<span class="string">'Carrie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: bus3.pick(<span class="string">'Dave'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: bus3.passengers</span><br><span class="line">Out[<span class="number">43</span>]: [<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: bus2.passengers</span><br><span class="line">Out[<span class="number">44</span>]: [<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: bus2.passengers <span class="keyword">is</span> bus3.passengers</span><br><span class="line">Out[<span class="number">45</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">46</span>]: [<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br></pre></td></tr></table></figure>
<p>可以看到bus2和bus3共用了一组乘客，问题就是出在<code>self.passengers = passengers</code>，这里如果我们在创建对象时什么也不传则用了默认参<code>passengers=[]</code>，而默认参是在加载模块的时候定义，不会每次都创建，所以默认参是这个函数的属性，而这个属性是个可变对象的时候，那么修改了之后后续的都会受到影响</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><h4 id="爱生活，爱小丽"><a href="#爱生活，爱小丽" class="headerlink" title="爱生活，爱小丽"></a>爱生活，爱小丽</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Python/Python-记学习对象可变性/" data-id="cjfx8rx03000fi4fyntq1qgpf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义banner实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-自定义banner实现/" class="article-date">
  <time datetime="2018-04-13T00:48:55.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-自定义banner实现/">Android-自定义banner实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>惯例先上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-f438927e8fb53ae2.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>可以看到这是一个轮播图，只不过我们以前在用的时候一般都是用ViewPager，用正常的ViewPager有几点坏处：</p>
<ul>
<li>不能无限循环</li>
<li>不能控制自动播放</li>
</ul>
<p>所以这就需要自己封装一个了，其实还是用的ViewPager，只不过更改了他的触摸事件并且设置了自动轮播的时间，然后自己写了一个PagerAdapter来实现无限轮播，最后下面的指示器和ViewPager、PagerAdapter封装到了一起，所以使用的时候很简单。<strong>只需要继承自BannerPagerAdapter，重写构造和setView()方法。然后在使用的时候调用方法即可</strong>，基本代码如下：</p>
<pre><code>List&lt;Integer&gt; data = new ArrayList&lt;&gt;();
data.add(R.mipmap.a1);
data.add(R.mipmap.a2);
data.add(R.mipmap.a3);
data.add(R.mipmap.a4);


AdapterDemo ad = new AdapterDemo(this, data);

Banner banner = (Banner) findViewById(R.id.banner);

/**
 * 关于这里的设置参数问题,是需要这样使用的
 * 在设置了小圆点之后才能设置适配器
 * 因为只有在适配器里才会根据一共多少条数据来适配
 * 最后需要调用开始轮播
 * 个人建议在onPause()/onDestroy()方法中来停止 -- stopAutoPlay()
 */
banner.setDot(R.drawable.no_selected_dot, R.drawable.selected_dot).
    setDotGravity(Banner.CENTER).
    setAdapter(ad).
    setOnItemClickListener(new BannerPagerAdapter.onItemClickListener() {
        @Override
        public void onClick(int position) {
            Toast.makeText(MainActivity.this, &quot;&quot; + position, Toast.LENGTH_SHORT).show();
        }
    }).
    startAutoPlay(); 
</code></pre><p>下面是AdapterDemo的代码：</p>
<pre><code>public class AdapterDemo extends BannerPagerAdapter {

    private Context mContext;
    private List&lt;Integer&gt; data;

    public AdapterDemo(Context context, List data) {
        super(context, data);
        mContext = context;
        this.data = data;
    }

    /**
     * 只需要重写构造和这个方法即可
     * 在这里可以设置自己的View,使用自己的图片加载库
     */
    @Override
    public View setView(int position) {
        View v = LayoutInflater.from(mContext).inflate(R.layout.test, null);
        ImageView iv = (ImageView) v.findViewById(R.id.iv);
        iv.setImageResource(data.get(position));
        return v;
    }
}
</code></pre><p>可以看的出来这里给调用者很大的空间来进行自己的操作，在setView中直接可以根据position来设置自己的View和数据，<strong>并且使用自己的图片加载库。</strong></p>
<p>如果感兴趣的可以移步<a href="https://github.com/wanglu1209/Banner" target="_blank" rel="noopener">GitHub</a></p>
<hr>
<p><strong>下面开始说如何写</strong></p>
<p>首先我们要确定一下这个banner有几个需要注意的点：</p>
<ol>
<li>无限轮播</li>
<li>点击事件</li>
<li>指示器</li>
<li>指示器的滑动效果</li>
</ol>
<h3 id="无限轮播、点击事件"><a href="#无限轮播、点击事件" class="headerlink" title="无限轮播、点击事件"></a>无限轮播、点击事件</h3><p>关于无限轮播，我参照的是任玉刚大神的博客，所以我也希望各位去看这个博客，也算是涨点人气，我这里就不写到底如何实现的了，各位可以查看我的代码</p>
<p><a href="http://blog.csdn.net/singwhatiwanna/article/details/46541225" target="_blank" rel="noopener">循环广告位组件的实现 – 任玉刚</a></p>
<h3 id="指示器、滑动效果"><a href="#指示器、滑动效果" class="headerlink" title="指示器、滑动效果"></a>指示器、滑动效果</h3><p>其实我写的时候有好多坑，但是写这篇文章的时候感觉都不是特别难的点（<strong>技术太菜</strong>）</p>
<p>关于指示器，其实现在大部分都是小圆点，这里我实现的思路是创建一个FrameLayout来添加ViewPager和指示器</p>
<p>但是可以看到，这里的指示器会有一个随着页面滑动而滑动的效果，这里就需要两层了，<strong>一个是包含未选中的，一个是包含了选中和未选中的（Group）</strong></p>
<p>代码如下：</p>
<pre><code>private void init() {
    mPager = new BannerViewPager(mContext);
    addView(mPager);
    /**
     * 实例化两个Group
     */
    mFrameLayout = new FrameLayout(mContext);
    mDotGroup = new LinearLayout(mContext);
    /**
     * 设置小圆点Group的方向为水平
     */
    mDotGroup.setOrientation(LinearLayout.HORIZONTAL);
    /**
     * 如果不设置则小圆点在中间
     */
    mDotGroup.setGravity(CENTER | Gravity.BOTTOM);
    /**
     * 两个Group的大小都为match_parent
     */
    LinearLayout.LayoutParams params =
            new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT);
    /**
     * 首先添加小圆点的Group
     */
    mFrameLayout.addView(mDotGroup, params);
    /**
     * 然后添加包含的Group（f**k,表达能力有限）
     */
    addView(mFrameLayout, params);

    /**
     * 添加到任务栈,当前所有任务完事之后添加已经选中的那个小圆点
     */
    post(new Runnable() {
        @Override
        public void run() {
            ImageView iv = new ImageView(mContext);
            iv.setImageDrawable(mContext.getResources().getDrawable(mDot[1]));
            FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            /**
             * 设置选中小圆点的左边距
             */
            params.leftMargin = (int) mDotGroup.getChildAt(0).getX();
            params.gravity = Gravity.BOTTOM;
            mFrameLayout.addView(iv, params);
            mSelectedDot = mFrameLayout.getChildAt(1);
        }
    });
    mPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            /**
             * 获取到当前position
             */
            position %= mAdapter.size;
            /**
             * 判断如果当前的position不是最后一个,那么就设置偏移量来实现被选中小圆点的滑动效果
             */
            if (mSelectedDot != null &amp;&amp; position != mAdapter.size -1) {
                float dx = mDotGroup.getChildAt(1).getX() - mDotGroup.getChildAt(0).getX();
                mSelectedDot.setTranslationX((position * dx) + positionOffset * dx);
            }
        }

        @Override
        public void onPageSelected(int position) {
            position %= mAdapter.size;
            /**
             * 如果已经是最后一个,那么则直接把小圆点定位到那,不然滑动效果会出错
             */
            if (mSelectedDot != null &amp;&amp; position == mAdapter.size - 1) {
                float dx = mDotGroup.getChildAt(1).getX() - mDotGroup.getChildAt(0).getX();
                mSelectedDot.setTranslationX(position * dx);
            }
        }

        @Override
        public void onPageScrollStateChanged(int state) {

        }
    });

}
</code></pre><p>可以看到我们首先添加了ViewPager，然后我们添加了未选中指示器的Group，之后我们才添加的选中的指示器。在添加选中指示器的时候用了一个post，这个方法是把runnable里的代码添加到任务栈，前面的任务结束了这个任务才会执行，所以我们可以获取到第一个未选中小圆点的坐标，然后把选中指示器覆盖上去，后来我们移动的时候就直接移动选中的指示器就好了。</p>
<p>关于滑动指示器，其实就是用了一个setTranslationX()方法，这个方法可以虽然移动View的位置，但是没有真正的移动该View，所以我们在移动的时候根据position来计算，但是当移动到最后一个的时候就不应该用这个方法了，如果还用的话就会造成一种『出界』了的感觉，所以这里在最后一个的时候不进入方法。</p>
<p>有人应该会想到『在第一页的时候』，这里我们大家可以自己测试一下，当手指向右滑的时候，就已经是size-1页了，所以我们直接就用一个判断就够了</p>
<p><strong>额，写的乱七八糟，但是代码会说话的~</strong></p>
<p><strong>还是那句话，感兴趣的请移步GitHub哟~</strong></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-自定义banner实现/" data-id="cjfx8rwzv000bi4fy9twk7v7y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义View" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-自定义View/" class="article-date">
  <time datetime="2018-04-13T00:40:13.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-自定义View/">Android - 自定义View</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Android-自定义View"><a href="#Android-自定义View" class="headerlink" title="Android - 自定义View"></a>Android - 自定义View</h3><hr>
<p>在自定义View的时候一般我们会重写onDraw(Canvas canvas)方法，然后在系统给定的canvas画布上绘画就可以了。如果需要使用wrap_content属性，那么还需要重写onMeasure()方法</p>
<blockquote>
<p>对现有的控件来进行扩展</p>
</blockquote>
<p>这里以TextView为例，要实现这样的一个效果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-f3394b37f9c32fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>只是在原有的TextView上加了一层框，其实就是绘制一个空心的矩形，理解这个我们就可以着手写代码了</p>
<pre><code>protected void onDraw(Canvas canvas) {
    /**
     * 在调用super之前，这里也就是在绘制文本内容前来处理自己的逻辑
     */
    Paint p = new Paint();    
    p.setStyle(Paint.Style.STROKE);    //设置为空心
    p.setStrokeWidth(5);                //设置外框线的宽度
    p.setColor(Color.YELLOW);            //设置线的颜色
    /**
     * 绘制矩形，起始x坐标，起始y坐标，终点x坐标，终点y坐标，用来绘画的paint
     */
    canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), p);

    super.onDraw(canvas);

    /**
     * 在绘制完文本后处理自己的逻辑
     */
}
</code></pre><p>这时候就完成了对现有的控件的扩展，我们在XML中使用我们自定义的控件</p>
<pre><code>&lt;com.github.wanglu1209.MyTextViewDemo
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_margin=&quot;20dp&quot;
    android:text=&quot;My Android TextView&quot; /&gt;
</code></pre><p>这里和使用正常的TextView没有什么区别，现在运行一下程序就是我们上面看到的效果了</p>
<hr>
<blockquote>
<p>定义全新的控件</p>
</blockquote>
<p>有的时候系统给定的控件不能满足我们的需求，那么这个时候就需要重新自定义一个控件。这里我们就需要重写onMeasure()和onDraw()方法等方法来实现逻辑了，通过重写onTouchEvent()来实现触控的事件</p>
<p>来写一个实例，大约就长这个样子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-7cc5ae38e23d1af6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>首先来分析一下，无非就是两个部分，中间的圆和外面的弧线，只要在onDraw()中依次绘制就可以了。</p>
<p>在构造中初始化参数</p>
<pre><code>private void initView() {
    mCirclePaint = new Paint();
    mCirclePaint.setColor(getResources().getColor(android.R.color.holo_blue_bright));
    mCirclePaint.setAntiAlias(true);    //设置抗锯齿

    mArcPaint = new Paint();
    mArcPaint.setAntiAlias(true);
    mArcPaint.setStyle(Paint.Style.STROKE);     //设置为空心
    mArcPaint.setStrokeWidth(40);
    mArcPaint.setColor(getResources().getColor(android.R.color.holo_blue_bright));

}
</code></pre><p>然后在onMeasure()中获取宽度，这里为了简单，直接就是屏幕的宽度</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int length = MeasureSpec.getSize(widthMeasureSpec);
    mCircleXY = length / 2;
    mRadius = mCircleXY / 2;
    mRectF = new RectF(
            (float) (length * 0.1),
            (float) (length * 0.1),
            (float) (length * 0.9),
            (float) (length * 0.9)
    );
}
</code></pre><p>最后在onDraw()中绘制这两个图形即可</p>
<pre><code>protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    /**
     * 绘制圆形,参数依次为 圆的中心x坐标,圆的中心y坐标,圆的半径,画圆的笔
     */
    canvas.drawCircle(mCircleXY, mCircleXY, mRadius, mCirclePaint);
    /**
     * 绘制扇形,参数依次为 扇形的大小,起始角度,角度,是否与半径连线,画笔
     */
    canvas.drawArc(mRectF, 270, 240, false, mArcPaint);
}
</code></pre><p>现在运行程序，就可以看到我们最开始的效果啦</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-自定义View/" data-id="cjfx8rwzo0008i4fyzukebavw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义ViewGroup" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-自定义ViewGroup/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-自定义ViewGroup/">自定义ViewGroup</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><blockquote>
<p>自定义ViewGroup需要注意什么</p>
</blockquote>
<p>首先我们要明确一点，ViewGroup就是用来存放View的容器，用来对子View进行管理，给子View添加规则，so</p>
<ol>
<li>对子View进行测量，重写onMeasure()方法</li>
<li>对子View的布局进行控制，重写onLayout()方法</li>
<li>重写onTouchEvent()，dispatchEvent()来对点击触控事件进行控制</li>
</ol>
<hr>
<blockquote>
<p>实例</p>
</blockquote>
<p><strong>长这个样子</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-d70282c81ab583c5.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>从这个图就可以看的出来我们的需求</p>
<ol>
<li>可以滑动</li>
<li>当滑动大于一定距离的时候显示下一个子View</li>
<li>如果小于一定距离那么就回到原位</li>
</ol>
<p>首先这里可以看的出来，我们每一个子View都是沾满一个屏幕的，所以这里整个ViewGroup的高度就能确定出来了，就是屏幕的高度乘子View的个数</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int count = getChildCount();
    for (int i = 0; i &lt; count; i++) {
        View child = getChildAt(i);         //获得每一个子view
        measureChild(child, widthMeasureSpec, heightMeasureSpec);      //测量子view
    }
}
</code></pre><p>我们先在onMeasure()方法中测量每一个子View，这里直接调用measureChild()方法就可以进行对子View的测量，用一个for循环很方便。</p>
<pre><code>protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int childCount = getChildCount();
    MarginLayoutParams mlp = (MarginLayoutParams) getLayoutParams();
    /**
     * 这里对整个ViewGroup的高度进行初始化
     * 屏幕的高度乘子View的个数
     */
    mlp.height = mScreenHeight * childCount; 
    setLayoutParams(mlp);


    for (int i = 0; i &lt; childCount; i++) {
        View child = getChildAt(i);
        if (child.getVisibility() != View.GONE) {
            /**
             * 这里对子View进行布局,由于我们的ViewGroup是上下滑动
             * 所以只需要确定top和bottom两个值就可以,让他们从上到下排列
             */
            child.layout(
                    l,
                    i * mScreenHeight,
                    r,
                    (i + 1) * mScreenHeight
            );
        }
    }
}
</code></pre><p>到这里我们就已经完成了对ViewGroup的测量和对子View位置的控制，接下来就是对触摸事件进行控制</p>
<pre><code>public boolean onTouchEvent(MotionEvent event) {
    int y = (int) event.getY();

    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mLastY = y;
            mStartY = getScrollY();
            break;
        case MotionEvent.ACTION_MOVE:
            if (!mScroller.isFinished()) {
                mScroller.abortAnimation();
            }
            int dy = mLastY - y;

            /**
             * getScrollY()小于0则为第一屏
             */
            if (getScrollY() &lt; 0) {
                dy = 0;
            }
            /**
             * 最后一屏
             */
            if (getScrollY() &gt; mTotalHeight - mScreenHeight) {
                dy = 0;
            }
            scrollBy(0, dy);
            mLastY = y;
            break;
        case MotionEvent.ACTION_UP:
            int dScrollY = check();

            if (dScrollY &gt; 0) { //从下往上滑
                /**
                 * 如果这个距离小于屏幕的1/3
                 * 那么就回到原位,也就是当前距离取负值
                 * 如果大于屏幕的1/3
                 * 那么就直接进入到下一个子View
                 */
                if (dScrollY &lt; mScreenHeight / 3) {
                    mScroller.startScroll(
                            0, getScrollY(),
                            0, -dScrollY)
                    ;
                } else {
                    mScroller.startScroll(
                            0, getScrollY(),
                            0, mScreenHeight - dScrollY
                    );
                }
            } else {
                if (-dScrollY &lt; mScreenHeight / 3) {
                    mScroller.startScroll(
                            0, getScrollY(),
                            0, -dScrollY
                    );
                } else {
                    mScroller.startScroll(
                            0, getScrollY(),
                            0, -mScreenHeight - dScrollY
                    );
                }
            }
            break;

    }
    postInvalidate();   //重绘
    return true;
}

private int check() {
    int mEnd = getScrollY();
    /**
     * 判断滑动方向
     * true 从下往上滑
     * false 从上往下滑
     */
    boolean isUp = mEnd - mStartY &gt; 0;
    /**
     * 关于这两个变量,读者可以自行的打印出来理解一下
     * 用语言来描述不好描述（好吧,其实是表达能力有限）
     */
    int lastPrev = mEnd % mScreenHeight;
    int lastNext = mScreenHeight - lastPrev;
    if (isUp) {
        return lastPrev;
    } else {
        return -lastNext;
    }
}

@Override
public void computeScroll() {
    super.computeScroll();
    if(mScroller.computeScrollOffset()){
        scrollTo(0, mScroller.getCurrY());
        postInvalidate();
    }
}
</code></pre><ol>
<li>这里我们首先在ActionDown事件中获取到第一次碰到屏幕时候的Y轴偏移量</li>
<li>然后我们在ActionMove事件中来对这个值来进行运算并且调用scrollBy()方法来进行滑动</li>
<li>最后我们在ActionUp方法中对这个事件进行总的处理，首先我们在check()方法中判断用户是从上往下滑还是从下往上滑，然后通过滑动方向来计算值并且返回，接着我们用check()方法返回的数据来进行判断滑动的距离是否大于屏幕的三分之一，如果大于，则调用Scroller.startScroll()方法来进行滑动到下/上一屏，如果小于则返回原位。</li>
</ol>
<p>至此自定义ViewGroup就完全结束了，运行一下程序，可以看到我们开始的效果已经呈现出来了。</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-自定义ViewGroup/" data-id="cjfx8rwzs000ai4fyt1fnpxhk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-ViewDragHelper" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-ViewDragHelper/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-ViewDragHelper/">Android-ViewDragHelper</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h2><hr>
<p>我们都知道在Google发布的support包中包含了DrawerLayout和SlidingPaneLayout这两个可以滑动的控件，其实这两个布局背后就隐藏着ViewDragHelper。通过ViewDragHelper基本上的滑动需求都可以满足，所以这个方法是<strong>各种滑动解决方案的终极绝招</strong></p>
<p>下面我们来进行一个实例，来使用一下ViewDragHelper，类似于QQ的侧滑菜单。废话不多说，上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-6892239ec9b94b03.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h3 id="使用ViewDragHelper"><a href="#使用ViewDragHelper" class="headerlink" title="使用ViewDragHelper"></a>使用ViewDragHelper</h3><ol>
<li>初始化ViewDragHelper</li>
<li>重写拦截、触摸事件交给ViewDragHelper处理</li>
<li>处理computeScroll()</li>
<li>处理回调接口Callback</li>
</ol>
<h3 id="初始化ViewDragHelper"><a href="#初始化ViewDragHelper" class="headerlink" title="初始化ViewDragHelper"></a>初始化ViewDragHelper</h3><p>ViewDragHelper<strong>通常定义在一个ViewGroup的内部，并通过静态工厂方法进行初始化，</strong>代码如下：</p>
<pre><code>mHelper = ViewDragHelper.create(this, callback);
</code></pre><p>对，就这一行代码，这里的this就是只一个ViewGroup了，callback就是刚才我们说的回调接口</p>
<h3 id="重写拦截、触摸事件交给ViewDragHelper处理"><a href="#重写拦截、触摸事件交给ViewDragHelper处理" class="headerlink" title="重写拦截、触摸事件交给ViewDragHelper处理"></a>重写拦截、触摸事件交给ViewDragHelper处理</h3><pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {
    mHelper.processTouchEvent(event);
    return true;
}

@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    return mHelper.shouldInterceptTouchEvent(ev);
}
</code></pre><p>这里就是一个事件拦截和触摸事件监听，上一文中都讲过，这里不在多说，就是调用了DragViewHelper的两个方法而已</p>
<h3 id="处理computeScroll"><a href="#处理computeScroll" class="headerlink" title="处理computeScroll()"></a>处理computeScroll()</h3><p>因为ViewDragHelper也是通过Scroller来实现平滑移动的，所以我们要重写computeScroll()方法，一般代码如下：</p>
<pre><code>@Override
public void computeScroll() {
    if (mHelper.continueSettling(true)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
}
</code></pre><h3 id="处理回调接口Callback"><a href="#处理回调接口Callback" class="headerlink" title="处理回调接口Callback"></a>处理回调接口Callback</h3><p>处理回调接口就是最关键的代码了，我们一般需要重写这几个方法</p>
<ul>
<li>tryCaptureView<ul>
<li>这个方法是自动创建的，通过这个方法可以指定哪一个子View可以移动</li>
</ul>
</li>
<li>clampViewPositionHorizontal<ul>
<li>这个方法对应的是水平上的滑动</li>
</ul>
</li>
<li>clampViewPositionVertical<ul>
<li>这个方法对应的是垂直上的滑动</li>
<li>如果想要滑动，这两个方法是必须要重写其中一个或者全部重写的，因为方法默认返回0，即不发生滑动</li>
</ul>
</li>
<li>onViewReleased<ul>
<li>这个方法在手指离开屏幕后调用</li>
</ul>
</li>
</ul>
<p>不多说，直接把代码撸上来，非常简单，对照注释一看就懂，整体代码如下</p>
<pre><code>public class ViewDragHelperDemo extends FrameLayout {

    ViewDragHelper mHelper;
    View mainView, menuView;

    public ViewDragHelperDemo(Context context) {
        this(context, null);
    }

    public ViewDragHelperDemo(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public ViewDragHelperDemo(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        /**
         * 初始化ViewDragHelper
         */
        mHelper = ViewDragHelper.create(this, callback);
    }


    ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {
        @Override
        public boolean tryCaptureView(View child, int pointerId) {
            /**
             * 决定滑动的View
             */
            return child == mainView;
        }

        @Override
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            /**
             * 水平方向上的移动
             */
            return left;
        }

        @Override
        public void onViewReleased(View releasedChild, float xvel, float yvel) {
            super.onViewReleased(releasedChild, xvel, yvel);
            /**
             * 当手指离开屏幕后,如果当前移动的View和父布局之间的距离小于150,那么则移动回原位
             * 如果大于150,那么则滑动到300
             */
            if (mainView.getLeft() &lt; 150) {
                mHelper.smoothSlideViewTo(mainView, 0, 0);
            }else{
                mHelper.smoothSlideViewTo(mainView, 300, 0);
            }

            /**
             * 通知重绘
             */
            ViewCompat.postInvalidateOnAnimation(DragViewHelperDemo.this);
        }
    };

    /**
     * 此方法会在布局加载完毕调用,我们把第一个布局设置为menuView,第二个设置为mainView
     */
    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        menuView = getChildAt(0);
        mainView = getChildAt(1);
    }

    /**
     * 这里设置触摸/拦截事件给DragViewHelper
     */
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        mHelper.processTouchEvent(event);
        return true;
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        return mHelper.shouldInterceptTouchEvent(ev);
    }

    /**
     * 设置computeScroll
     */
    @Override
    public void computeScroll() {
        if (mHelper.continueSettling(true)) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }
}
</code></pre><p>运行程序，就会看到和上面一样的效果啦。ViewDragHelper是最麻烦的一种，但是多写一写就好啦~</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-ViewDragHelper/" data-id="cjfx8rwz50004i4fy65b3swmq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-View的滑动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-View的滑动/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-View的滑动/">Android-View的滑动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>滑动效果是如何产生的？</p>
</blockquote>
<p>滑动一个View从本质上来说就是移动一个View，改变其当前的坐标。所以，想要滑动一个View，就必须监听该View的触摸事件，并且根据事件的坐标，不断的改变View的坐标从而实现View的滑动。</p>
<h2 id="Android中的坐标体系"><a href="#Android中的坐标体系" class="headerlink" title="Android中的坐标体系"></a>Android中的坐标体系</h2><p>Android中的坐标体系分为两种：</p>
<ol>
<li>Android坐标系</li>
<li>视图坐标系</li>
</ol>
<blockquote>
<p>Android坐标系</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-0ea610d2436d0fe0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android坐标系"></p>
<p>从图中我们可以看的出来<strong>在Android坐标系中以屏幕的左上方作为坐标系的原点，从原点向右为X轴的正方向，向下为Y轴的正方向</strong>。在触控事件中使用<strong>getRawX()、getRawY()</strong>来获得Android坐标系的坐标</p>
<blockquote>
<p>视图坐标系</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-a6921068bc9cf072?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视图坐标系"></p>
<p>视图坐标系主要描述的是该View和该View在父视图中的位置关系，和Android坐标系一样，也是以原点右方为X正方向，以原点下方为Y轴正方向，不过这里不是以屏幕的左上角为原点，而是<strong>以父视图的左上角为原点</strong>。在触控事件中使用<strong>getX()、getY()</strong>来获得视图坐标系的坐标</p>
<h2 id="触控事件"><a href="#触控事件" class="headerlink" title="触控事件"></a>触控事件</h2><p>在上一篇文章中我们使用到了MotionEvent，这个就是触控事件的封装，首先看一下MotionEvent中封装的事件常量</p>
<ul>
<li>public static final int ACTION_DOWN = 0;    //单点触摸按下动作</li>
<li>public static final int ACTION_UP = 1;    //单点触摸离开动作</li>
<li>public static final int ACTION_MOVE = 2;    //单点触摸移动动作</li>
<li>public static final int ACTION_CANCEL = 3;    //触摸动作取消</li>
<li>public staiic final int ACTION_OUTSIDE = 4;    //触摸动作超出边界</li>
<li>public static final int ACTION_POINTER_DOWN = 5; //多点触摸按下动作</li>
<li>public static final int ACTION_POINTER_UP = 6; 多点离开动作</li>
</ul>
<p>通常情况下我们会在onTouchEvent(MotionEvent event)方法中通过event.getAction()来获取触控事件的类型。知道Android中的坐标系和触控事件之后我们就可以来实现View的滑动了</p>
<hr>
<h1 id="滑动实现"><a href="#滑动实现" class="headerlink" title="滑动实现"></a>滑动实现</h1><blockquote>
<p>实现滑动有好多种方法，但是其思想都是一样的。当触摸到View时，记录当前触摸点的坐标，然后当手指移动时，获取到相对于前一个点的偏移量，这样我们就可以通过这个偏移量来进行修改View的坐标，这样不断的重复，就能实现View的滑动</p>
</blockquote>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>我们自定义一个View，让他来跟随我们手指的移动来移动，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-82d4117c39eaf270.gif?imageMogr2/auto-orient/strip" alt=""></p>
<ul>
<li><strong>layout方法</strong></li>
</ul>
<p>我们知道在View进行绘制的时候会通过onLayout()方法来设置View的显示位置，这里我们通过修改View的left, top, right, bottom四个值来控制View的坐标</p>
<pre><code>public boolean onTouchEvent(MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            //记录触摸点的坐标
            lastX = x;
            lastY = y;
            break;
        case MotionEvent.ACTION_MOVE:
            //计算偏移量
            int offsetX = x - lastX;
            int offsetY = y - lastY;

            //在当前位置基础加上偏移量
            layout(
                    getLeft() + offsetX,
                    getTop() + offsetY,
                    getRight() + offsetX,
                    getBottom() + offsetY
            );
            break;
    }
    return true;
}
</code></pre><hr>
<ul>
<li><strong>offsetLeftAndRight()和offsetTopAndBottom</strong></li>
</ul>
<p>这个方法就是相当于系统提供的一个对左右、上下移动的API的封装，计算好偏移量后，调用方法即可：</p>
<pre><code>offsetLeftAndRight(offsetX);
offsetTopAndBottom(offsetY);
</code></pre><hr>
<ul>
<li><strong>LayoutParams</strong></li>
</ul>
<p>LayoutParams保存了View的布局参数，所以我们可以改变LayoutParams来动态的改变布局的位置来达到滑动的效果。在程序中使用getLayoutParams()来获取当前View的LayoutParams，这里就和上面一样，获取到偏移量后通过setLayoutParams来设置该View的LayoutParams：</p>
<pre><code>RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) getLayoutParams();
params.leftMargin = getLeft() + offsetX;
params.topMargin = getTop() + offsetY;
setLayoutParams(params);
</code></pre><p><strong>需要注意一点，通过getLayoutParams()获取LayoutParams的时候，要根据View的父布局的类型来设置，当然前提还要有一个父布局。还有就是我们可以使用ViewGroup.MarginLayoutParams，这样就不用考虑父布局是什么了</strong></p>
<hr>
<ul>
<li><strong>scrollTo、scrollBy</strong></li>
</ul>
<p>在View中，系统还提供了scrollTo、scrollBy两种方式来改变一个View的位置。</p>
<p>其中scrollTo表示移动到一个具体的坐标点，scrollBy表示移动的偏移量，其实在scrollBy内部也是调用的scrollTo。</p>
<p>和前面的方式一样，获取到偏移量后调用scrollBy来移动view，可是当我们运行程序，拖动View，发现View并没有移动！这是因为scrollTo、scrollBy方法移动的是View的内容，如果在ViewGroup中使用scrollTo、scrollBy的滑，那么移动的就是View了，但是如果在View中使用，那么移动的将是View里面的内容，比如TextView，那么移动的就是文本了。</p>
<p>所以通过上面的分析，我们把代码改为如下:</p>
<pre><code>((View)getParent()).scrollBy(offsetX, offsetY);
</code></pre><p>再次运行程序，我们会发现动是动了，但是在乱动。因为这里我们其实是在相反的方向移动（这里由于篇幅限制，感兴趣的同学自行查找一下资料），我们把偏移量改为负的之后就会发现滑动正常了。</p>
<hr>
<ul>
<li><strong>Scroller</strong></li>
</ul>
<p>首先来想一个场景：我们需要让一个Button向右面移动100个像素，如果我们用scrollTo/scrollBy的话，那么该View就会很突兀的移动到该点，没有过程，而Scroller则是可以实现平滑的过渡效果的</p>
<p>下面我们把上面跟随手指滑动的例子改一下，我们在松开手指后，View自动回到原点（屏幕左上角）。使用Scroller需要三个步骤</p>
<ol>
<li>初始化<ul>
<li>通过构造方法即可   Scroller mScroller = new Scroller(context);</li>
</ul>
</li>
<li>重写computeScroll()方法，实现滑动</li>
<li>startScroll()开启滑动</li>
</ol>
<p>代码如下：</p>
<pre><code>        case MotionEvent.ACTION_UP:
            View viewGroup = (View) getParent();
            mScroller.startScroll(
                    viewGroup.getScrollX(),
                    viewGroup.getScrollY(),
                    -viewGroup.getScrollX(),
                    -viewGroup.getScrollY()
            );
            invalidate();
            break;

  ----------------------------------------------------------------     

        @Overrid  
        public void computeScroll() {
            super.computeScroll();
            if (mScroller.computeScrollOffset()) {
            ((View) getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            invalidate();
    }
}
</code></pre><p>当我们手指抬起来的时候开启Scroller滑动，获取到当前view的移动距离，然后我们把需要移动的偏移量设置为相反数就ok，最后调用invalidate来通知重绘，从而调用computeScroll()方法。运行程序如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-2251dce7b4d1c1c7.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>现在就把这几种View的滑动都说完了，自己动手写一下，感触良多。</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-View的滑动/" data-id="cjfx8rwzd0006i4fy4wmihq9d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-各种情况下的『自动加载更多』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-各种情况下的『自动加载更多』/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-各种情况下的『自动加载更多』/">Android-各种情况下的『自动加载更多』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在写项目的时候总是会碰到上拉自动加载更多这个需求，但是又不想用PullToRefresh，其实我们可以直接判断出来是否已经滑动到底端，如果滑动到底端则加载。一般的需求有在ScrollView、RecyclerView、ListView中自动加载</p>
<h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><p>在RecyclerView中判断是否滑动到底部，其实就是判断是否已经达到了<strong>最后一个可见的item &amp;&amp; 滑动结束</strong>，伪代码如下</p>
<pre><code>RecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
    @Override
    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
        if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; 
            (layoutManager.findLastVisibleItemPosition() == 
            layoutManager.getItemCount() - 1)
            &amp;&amp; !isRefreshing) {
            isRefreshing = true;         
            //处理逻辑
        }
    }
});
</code></pre><p>解释一下上面的判断，当状态为SCROLL_STATE_IDLE(停止滑动)时，并且目前可见的最后一个item的位置为总数-1，并且当前不在刷新状态中（<strong>因为有的时候需要网络请求，所以可能滑动到底部后一直请求接口，定义一个变量来判断一下</strong>），然后就可以处理逻辑了</p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>关于ListView的滑动底部监听其实和RecyclerView的判断差不多，代码如下：</p>
<pre><code>ListView.setOnScrollListener(new OnScrollListener() {
            @Override
            public void onScrollStateChanged(AbsListView view, int scrollState) {

                    if((scrollState == OnScrollListener.SCROLL_STATE_IDLE) &amp;&amp;
                            view.getLastVisiblePosition() == (view.getCount() - 1)
                            &amp;&amp; !isRefreshing) {
                        //处理逻辑
                    }
                }
            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem,
                                 int visibleItemCount, int totalItemCount) {
            }
        });   
</code></pre><p>ListView和RecyclerView差不多，就不多做解释了    </p>
<h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><p>最后关于ScrollView滑动到底部，因为<strong>ScrollView没有停止滑动的监听，所以使用要慎重！</strong></p>
<p>如果想要使用ScrollView来监听，那就要重写ScrollView，代码如下：</p>
<pre><code>onScrollBottomListener bottomListener;

public void setOnScrollBottomListener(onScrollBottomListener bottomListener){
    this.bottomListener = bottomListener;
}

public interface onScrollBottomListener{
    void onBottom();
}

@Override
protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);
    if(getHeight() + getScrollY() &gt;= getChildAt(0).getMeasureHeight()){
        if(bottomListener != null){
            bottomListener.onBottom();
        }
    }
}    
</code></pre><p>看的出来，我们定义了一个接口来回调，因为ScrollView里只能包含一个布局，所以可以根据这个特性来判断，所以在滑动事件监听里获取到当前ScrollView的高度和Y轴的滑动值的相加来和ScrollView包含的布局的高度来进行对比，如果大于的话那么就等于滑动到底部（<strong>但是这个方法会调用好多次</strong>）    </p>
<hr>
<p>以前工作的时候碰到过这些需求，当时在网上找也没有找到合适的（<strong>确实当时技术很菜</strong>），过了好久了，分享出来，希望后来又有需求的少碰坑- -</p>
<p>当然可以在布局的后面加一个FooterView，加载数据的时候显示『正在加载…』，加载到没有数据的时候显示一个『- end -』之类的</p>
<p>没写Demo，有兴趣的可以自己试试啦~</p>
<p>洗洗睡了，凌晨1:05</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-各种情况下的『自动加载更多』/" data-id="cjfx8rwzj0007i4fyw0h89aj5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-Activity启动模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-Activity启动模式详解/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-Activity启动模式详解/">Android-Activity启动模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="最近在写一个小Demo（然而现在也没写出来）。几天没更新，不知道有没有人还有一点点的小期待（估计没有）。让我边写文章边哭一会。。。"><a href="#最近在写一个小Demo（然而现在也没写出来）。几天没更新，不知道有没有人还有一点点的小期待（估计没有）。让我边写文章边哭一会。。。" class="headerlink" title="最近在写一个小Demo（然而现在也没写出来）。几天没更新，不知道有没有人还有一点点的小期待（估计没有）。让我边写文章边哭一会。。。"></a>最近在写一个小Demo（然而现在也没写出来）。几天没更新，不知道有没有人还有一点点的小期待（估计没有）。让我边写文章边哭一会。。。</h4><hr>
<h2 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h2><blockquote>
<p>为啥子需要启动模式？</p>
</blockquote>
<p>我们知道启动Activity时会把Activity放入一个任务栈，所以当我们按back键时就会从Activity从任务栈里清除，当任务栈里为空时，系统就会回收这个任务栈。<strong>举个例子</strong>，我们在当前Activity启动当前的Activity，那么任务栈里就全是当前Activity，这样当然很二逼了！所以启动模式就出来了，目前有四种启动模式</p>
<ul>
<li>standard</li>
<li>singleTop</li>
<li>singleTask</li>
<li>singleInstance</li>
</ul>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>standard是标准模式，也就是默认模式。每次启动一个Activity就会创建一个新的实例，不管这个实例是否已经存在，<strong>这就是典型的多实例实现。一个任务栈可以有多个实例，每个实例也可以属于不同的任务栈，谁启动了这个Activity，这个Activity就运行在启动它的那个任务栈中，</strong>当我们用ApplicationContext去启动一个standard模式的Activity会报错，因为standard的Activity会进入启动他的Activity任务栈中，但是由于非Activity类型的Context并没有任务栈，所以这样就出问题了</p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>singleTop即栈顶复用模式，在这种模式下，如果新创建的Activity已经位于栈顶，那么就不会去创建新的实例，但是该Activity的onNewIntent会被调用，通过这个方法我们可以取出请求的信息。<strong>需要注意的是，该Activity的onCreate、onStart不会被调用，因为它没有发生改变。</strong>但是如果新的Activity不位于栈顶，那么就会创建一个新的实例。<strong>举个例子</strong>，比如现在一个任务栈有ABCD四个Activity，A位于栈底，D位于栈顶。这个时候如果去启动D，那么栈的情况还是ABCD四个实例，如果D的启动模式为standard，那么栈内就是ABCDD</p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>栈内复用模式，在这种模式情况下，只要Activity在一个栈中存在，那么启动这个Activity都不会重新创建实例，也会调用onNewIntent。<strong>当一个singleTask模式的Activity『A』被请求启动，首先系统会寻找是否有A所需的任务栈，如果不存在，那就重新创建一个任务栈，然后创建A的实例放入栈中。如果存在A所需的任务栈，这时再看A是否在这个栈中有实例存在，如果存在，那么久回把A调到栈顶并调用onNewIntent方法。如果不存在，那么就创建A的实例并且压入栈中，举个例子</strong></p>
<ul>
<li>比如当前任务栈S1中有ABC三个实例，这个时候singleTask模式的D启动，但是其所需要的任务栈为S2，由于S2和D的实例都不存在，这个时候就会先创建S2任务栈，然后创建D的实例压栈到S2</li>
<li>如果D需要的任务栈为S1，那么由于任务栈S1已经存在，所以直接会创建D的实例放到S1任务栈中</li>
<li>如果D需要的任务栈为S1，并且S1的情况为ADBC，这时不会重新创建D的实例，会把D调用栈顶，同时<strong>singleTask默认具有clearTop效果，所以会导致D上面的Activity全部出栈</strong>，于是最终S1的情况为AD</li>
</ul>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>单例模式，加强的singleTask，这种模式的Activity只能单独运行在一个单独的任务栈中，其他和singleTask一样</p>
<blockquote>
<p>所需的任务栈？</p>
</blockquote>
<p>在singleTask中提到『所需的任务栈』，什么是Activity所需的任务栈？这里就要提一个参数：TaskAffinity。这个参数标识了一个Activity所需的任务栈的名字，默认情况下所有的Activity所需的任务栈都是当前包名，当然我们也可以为每个Activity单独指定TaskAffinity，<strong>注意这个属性值必须不能和包名相同，</strong>TaskAffinity主要和singleTask配合使用，否则的话没什么意义。当启动一个被TaskAffinity标识了的Activity，那么该Activity就会运行在和TaskAffinity相同的任务栈中</p>
<p>我们用两种方式设置Activity的启动模式</p>
<ol>
<li>在AndroidManifest里为Activity设置<br><code>android:launchMode=&quot;singleTop/singleTask/singleInstance&quot;</code></li>
<li>通过Intent设置标志位来指定<br><code>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</code></li>
</ol>
<p>这两种方式<strong>第二种的优先级要高于第一种，也就是说两者同时存在时，以第二种为准</strong></p>
<hr>
<h2 id="强行举个特殊的例子"><a href="#强行举个特殊的例子" class="headerlink" title="强行举个特殊的例子"></a>强行举个特殊的例子</h2><p>如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-2e7d2017412beb22.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>首先我们看一下AndroidManifest里的配置</p>
<pre><code>&lt;activity android:name=&quot;.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

&lt;activity
    android:name=&quot;.SecondActivity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;com.task1&quot; /&gt;

&lt;activity
    android:name=&quot;.ThirdActivity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;com.task1&quot; /&gt;
</code></pre><p>可以看到我们给SecondActivity和ThirdActivity设置了singleTask模式和taskAffinity，也就是所需的任务栈。从图里我们可以看出，首先由MainActivity启动SecondActivity，然后由SecondActivity启动ThirdActivity，再由ThirdActivity启动MainActivity，最后再启动SecondActivity。然后我们按两次回退键，发现回到了桌面了，这是为什么？</p>
<p>首先我们把MainActivity设为A，SecondActivity为B，ThirdActivity为C。</p>
<p>从Manifest文件中可以看到A为standard模式，任务栈为包名，而B和C是singleTask模式，任务栈为com.task1。</p>
<p>所以当我们从A启动B的时候，系统会为我们新建一个任务栈，就是com.task1，从而把B进栈。</p>
<p>从B启动C时，发现C所需要的任务栈com.task1已经存在，但是没有发现C的实例，这时候就创建C的实例并且进栈，这时com.task1里为BC</p>
<p>然后我们又从C启动A，由于A为standard模式，所以A会进入到C的任务栈，这时有两个任务栈存在，一个是为包名的任务栈，一个是为com.task1的任务栈。包名的任务栈里只有一个A，而com.task1的任务栈里现在是BCA</p>
<p>接着我们由A启动B，B是singleTask模式，而恰好当前栈里存在着B的实例，所以不会重新创建实例，而是把B调到栈顶，并且把前面的Activity通通出栈，此时com.task1的任务栈里就只剩下一个B了</p>
<p>最后我们按下一次回退键，当前B被出栈，com.task1任务栈被销毁，调出包名任务栈，也就是A，然后再按一次就退出程序了，这也就间接的证明了切换singleTask模式的Activity会把在它之上的Activity出栈。</p>
<hr>
<p>写了这么多字累死我了</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-Activity启动模式详解/" data-id="cjfx8rwyv0001i4fy9t6hpg08" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-属性动画" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-属性动画/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-属性动画/">Android-属性动画</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Android3.0以前的动画框架Animation存在着局限性：只能改变显示的位置，但是不能真正的更改View的位置，所以在Android3.0以后Google就推出了<strong>属性动画（Animator）</strong></p>
<p>在Animator框架动画中使用最多的就是ObjectAnimator和AnimatorSet。使用ObjectAnimator来进行控制，一个ObjectAnimator只能控制一个对象的一个值，而使用多个ObjectAnimator组合到一个AnimatorSet当中形成一个动画的集合。其中<strong>最重要的是属性动画通过调用属性的get/set方法来真实的控制一个View的属性</strong>，所以基本的的动画都可以用属性动画来实现</p>
<h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><p>创建一个ObjectAnimor只需要调用ObjectAnimator的静态工厂方法就可以直接返回一个ObjectAnimator对象，其属性有需要控制的对象，和对象的属性名（动画的名称），但是这个属性必须要有get、set方法，因为在内部会调用Java的反射机制来调用set函数修改属性值</p>
<h4 id="看一个小实例"><a href="#看一个小实例" class="headerlink" title="看一个小实例"></a>看一个小实例</h4><p>把一个Button向右方平移300，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-9118622cec9694b9.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>代码如下：</p>
<pre><code>btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        /**
         * 创建ObjectAnimator对象
         * 设置对象和对象属性还有值
         */
        ObjectAnimator oa = ObjectAnimator.ofFloat(btn, &quot;translationX&quot;, 300);
        oa.setDuration(300);    //设置时间为300ms
        oa.start();
    }
});
</code></pre><p>这里我们首先通过ObjectAnimator的静态工厂方法创建了一个对象，这里的三个参数：第一个参数则是需要曹工的对象，第二个是要操纵的属性，第三个是一个可变数组，这里我们只给了一个参数300，最后调用start()方法就可以看到动画啦。</p>
<h2 id="常用的可以直接使用的属性动画的值"><a href="#常用的可以直接使用的属性动画的值" class="headerlink" title="常用的可以直接使用的属性动画的值"></a>常用的可以直接使用的属性动画的值</h2><ul>
<li>translationX/translationY    ：作为一种增量来控制对象从它的父布局的左上角偏移的位置</li>
<li>rotation、rotationX、rotationY：控制对象围绕支点来进行2D和3D旋转</li>
<li>pivotX、pivotY：这两个属性控制着对象的支点位置，围绕着这个支点进行旋转和缩放，在默认情况下支点就是该对象的中心点</li>
<li>x、y：这两个属性描述了对象在他容器中的最终位置，他是最初的左上角坐标和translationX、translationY值的累积和</li>
<li>alpha：透明度，默认值是1（不透明），0代表完全透明</li>
</ul>
<p>可以看的出来大部分的动画都包含了，但是如果说有的属性没有get/set方法，那是不是就不能更改了呢？我们可以写一个自定义的属性类或者包装类来间接的给这个属性添加get/set方法。</p>
<p>来看一下包装类，代码如下：</p>
<pre><code>public class WrapperView {
    private View mTarget;

    public WrapperView(View mTarget) {
        this.mTarget = mTarget;
    }

    public int getWidth(){
        return mTarget.getLayoutParams().width;
    }

    public void setWidth(int width){
        mTarget.getLayoutParams().width = width;
        mTarget.requestLayout();
    }
}
</code></pre><p>通过以上的代码就给一个width属性进行了包装，等到使用的时候只需要通过包装类就可以间接的调用到get/set方法了，如下：</p>
<pre><code>btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        /**
         * 创建ObjectAnimator对象
         * 设置对象和对象属性还有值
         */
        ObjectAnimator oa = ObjectAnimator.ofInt(new WrapperView(btn), &quot;width&quot;, 500);
        oa.setDuration(300);
        oa.start();
    }
});
</code></pre><p>还是熟悉的配方，还是原来的味道！这里只不过我们换了一下创建ObjectAnimator对象的方法，因为我们的setWidth方法里的参数是int类型的，所以我们的静态工厂方法需要使用ofInt()方法，如果还是使用ofFloat()的话会提示<code>W/PropertyValuesHolder: Method setWidth() with type float not found on target class class com.androidqunyingzhuan.WrapperView</code>。没有找到类型为float的set方法，运行一下程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-38e42ab877d3ddfc.gif?imageMogr2/auto-orient/strip" alt=""></p>
<hr>
<h2 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h2><p>这个属性类似于AnimationSet，在属性动画中，如果针对同一个对象的多个属性并且同时作用多种动画就可以使用PropertyValuesHolder实现。比如在平移的过程中同时改变X、Y轴的缩放，代码如下：</p>
<pre><code>PropertyValuesHolder p1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 300);
PropertyValuesHolder p2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1, 0, 1);
PropertyValuesHolder p3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1, 0, 1);
ObjectAnimator.ofPropertyValuesHolder(btn, p1, p2, p3).setDuration(1000).start();
</code></pre><p>这样我们就把这三个动画同时作用在一个对象上了，运行程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-dcda53da332406d2.gif?imageMogr2/auto-orient/strip" alt=""></p>
<hr>
<h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><p>ValueAnimator在属性动画中是非常重要的，它是属性动画的核心所在，ObjectAnimator也是继承的ValueAnimator</p>
<p>ValueAnimator不提供任何动画的实现，他像是一个数值发生器，用来产生具有一定规律的数字，来让调用者控制动画的实现过程，通常情况下在ValueAnimator的AnimatorUpdateListener中监听数值的变化，来完成动画的变换</p>
<pre><code>ValueAnimator va = ValueAnimator.ofFloat(0, 100);
va.setDuration(2000).start();
va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator valueAnimator) {
        btn.setText(valueAnimator.getAnimatedValue() + &quot;&quot;);
    }
});
</code></pre><p>我们通过ofFloat()方法来创建了一个ValueAnimator对象，设置值的变换是从0f到100f，设置时间为2秒，然后我们在AnimatorUpdateListener中获取当前值让btn来显示，效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-5b58a04d86733d96.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h4 id="动画事件的监听"><a href="#动画事件的监听" class="headerlink" title="动画事件的监听"></a>动画事件的监听</h4><p>Android提供给我们了一个接口，可以很方便的监听到一个动画的所有过程：</p>
<pre><code>mAnimator.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animator) {

    }

    @Override
    public void onAnimationEnd(Animator animator) {

    }

    @Override
    public void onAnimationCancel(Animator animator) {

    }

    @Override
    public void onAnimationRepeat(Animator animator) {

    }
});
</code></pre><p>但是大部分的时候我们只会关心动画完成之后我们需要做些什么，所以Android还提供了一个适配器来让我们选择</p>
<pre><code>oa.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        super.onAnimationEnd(animation);
    }
});
</code></pre><hr>
<h2 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h2><p>对于在一个对象同一时间作用多个属性动画效果前面已经用PropertyValuesHolder实现了这样的效果，但是AnimatorSet不仅能实现这样的效果，同时能实现更为精确的顺序控制，下面我们用AnimatorSet来实现上面PropertyValuesHolder演示的动画。代码如下：</p>
<pre><code>ObjectAnimator a1 = ObjectAnimator.ofFloat(btn, &quot;translationX&quot;, 300);
ObjectAnimator a2 = ObjectAnimator.ofFloat(btn, &quot;scaleX&quot;, 1, 0, 1);
ObjectAnimator a3 = ObjectAnimator.ofFloat(btn, &quot;scaleY&quot;, 1, 0, 1);
AnimatorSet set = new AnimatorSet();
set.setDuration(1000);
set.playTogether(a1, a2, a3);
set.start();
</code></pre><p>这里我们只是想要和用PropertyValuesHolder演示的动画一样，所以我们使用了playTogether()方法来进行控制动画同时进行，当然还可以使用别的方法，例如playSequentially()，with()，before()，after()等方法来控制多个动画的工作方式，从而做到对动画播放顺序的精确控制，这里的动画和上面的一样，就不放图片了</p>
<hr>
<h2 id="animate方法"><a href="#animate方法" class="headerlink" title="animate方法"></a>animate方法</h2><p>Google在Android3.0以后，给View添加了一个animate方法来直接驱动属性动画，这可以认为是属性动画的简写形式，代码如下：</p>
<pre><code>btn.animate()
        .translationX(300)
        .y(300)
        .setDuration(1000)
        .withStartAction(new Runnable() {
            @Override
            public void run() {

            }
        }).withEndAction(new Runnable() {
            @Override
            public void run() {

            }
        }
).start();
</code></pre><p>设置了两个动画，这里是同时进行的，还有两个回调方法，开始和结束</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-5f721d3886a0442e.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p><strong>这样一来，简单的属性动画效果就都说完啦</strong></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-属性动画/" data-id="cjfx8rwzq0009i4fyhq4gb4vx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/">Python-学装饰器之前，有几个点要理解</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Python/Python-记学习对象可变性/">Python-记学习对象可变性</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义banner实现/">Android-自定义banner实现</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义View/">Android - 自定义View</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义ViewGroup/">自定义ViewGroup</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 王璐<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>