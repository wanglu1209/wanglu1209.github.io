<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>王璐的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="王璐的博客">
<meta property="og:url" content="http:/index.html">
<meta property="og:site_name" content="王璐的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王璐的博客">
  
    <link rel="alternate" href="/atom.xml" title="王璐的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">王璐的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http:"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Python/Python-学装饰器之前，有几个点要理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/" class="article-date">
  <time datetime="2018-04-13T00:50:44.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/">Python-学装饰器之前，有几个点要理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>要不这样吧，如果编程语言里有个地方你弄不明白，而正好又有个人用了这个功能，那就开枪把他打死，这比学习新特性要容易些，然后过不了多久，那些活下来的程序员就会开始用0.9.6版本的Python，而且他们只需要使用这个版本中易于理解的小部分就好了（眨眼）。                  - Tim Peters</p>
</blockquote>
<p>首先推荐一波和朋友一起弄的壁纸下载，爬取了各大网站的壁纸，总有你喜欢的类型。<a href="http://wp.d2collection.com/" target="_blank" rel="noopener">http://wp.d2collection.com/</a></p>
<p>众所周知，Python里装饰器是一个很重要并且很牛X的功能，他可以在不改变原函数的功能和结构的基础上增加新功能。</p>
<p>但是想要理解装饰器还是有很多知识点的：</p>
<ul>
<li>导入时、运行时</li>
<li>闭包与变量的作用域</li>
<li>nonlocal</li>
</ul>
<p>一般我们的装饰器都是在另外的一个文件里写的，类似xxx_deco。</p>
<p>当我们在别的文件中引入进来并且在自己的函数上定义时，装饰器就<strong>立即运行</strong>了。（当然不是说代码刚写就运行了+_+）</p>
<p>用《流畅的Python》中的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running register(&lt;function f1 at 0x10373d730&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10373d7b8&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x10373d730&gt;, &lt;function f2 at 0x10373d7b8&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure>
<p>从结果我们可以证实刚才的话，在装饰后，就已经运行了。</p>
<p>下面我们来讨论变量的问题，众所周知，一个函数内部的变量在函数执行结束后就被销毁了。那么我们看一个小例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>这是一个利用闭包实现的求平均数的方法，导入运行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> average <span class="keyword">import</span> make_averager</span><br><span class="line">In[<span class="number">3</span>]: avg = make_averager()</span><br><span class="line">In[<span class="number">4</span>]: avg(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">10.0</span></span><br><span class="line">In[<span class="number">5</span>]: avg(<span class="number">11</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">10.5</span></span><br><span class="line">In[<span class="number">6</span>]: avg(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">11.0</span></span><br></pre></td></tr></table></figure>
<p>这里爱思考的盆友会看出来，每次值都被记录了下来，我当时看到这里的时候在想，这不是坑爹么！谁说局部变量执行完就销毁的(╯‵□′)╯︵┻━┻</p>
<p>跑回去看了一下闭包的解释：<strong>：闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</strong></p>
<p>闭包延伸了变量的作用域，还起了个名字叫自由变量。所以上面的series就是一个自由变量。<strong>自由变量是指在本地作用域中绑定的变量</strong>，所以这个series没有被释放掉并且一直可以用。</p>
<p>那么这个时候再来看，如果我想统计有多少个数字呢？代码增加如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>运行如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> average <span class="keyword">import</span> make_averager</span><br><span class="line">In[<span class="number">3</span>]: avg = make_averager()</span><br><span class="line">In[<span class="number">4</span>]: avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/WangLu/.pyenv/versions/3.5.2/lib/python3.5/site-packages/IPython/core/interactiveshell.py"</span>, line <span class="number">2862</span>, <span class="keyword">in</span> run_code</span><br><span class="line">    exec(code_obj, self.user_global_ns, self.user_ns)</span><br><span class="line">  File <span class="string">"&lt;ipython-input-4-2b3d43cb065d&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    avg(<span class="number">10</span>)</span><br><span class="line">  File <span class="string">"/Users/WangLu/Study/FluentPython/average.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> averager</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>报错了，在定义变量之前应用了变量。这跟刚才说的不一致。</p>
<p>在Python中，数字、元组等不可变类型是只读的，想要重新赋值就要重新创建变量，在刚才的例子中，如果重新创建变量的话那就不是自由变量了，没有自由变量的闭包还是闭包么？所以在Python3中引入了<strong>nonlocal</strong>声明，被nonlocal声明的变量为自由变量，闭包中的数据就会更新。</p>
<p>所以，代码改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    series = []</span><br><span class="line">    count = 0</span><br><span class="line"></span><br><span class="line">    def averager(new_value):</span><br><span class="line">        nonlocal count</span><br><span class="line">        count += 1</span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        return total / len(series)</span><br><span class="line"></span><br><span class="line">    return averager</span><br></pre></td></tr></table></figure>
<p>如果是Python2的话，就需要把变量设置为可变的如list等</p>
<p>至此，我们就可以来实现装饰器了，在每次调用的时候输出 哈哈 + 方法名 + 结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha_deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(*args)</span>:</span></span><br><span class="line">        result = func(*args)</span><br><span class="line">        print(<span class="string">'哈哈 -&gt; &#123;&#125;，结果为：&#123;&#125;'</span>.format(func.__name__, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> haha</span><br></pre></td></tr></table></figure>
<p>调用结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> haha_deco <span class="keyword">import</span> haha_deco</span><br><span class="line">In[<span class="number">3</span>]: @haha_deco</span><br><span class="line">  ...: <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(n)</span>:</span></span><br><span class="line">  ...:     <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * demo(n<span class="number">-1</span>)</span><br><span class="line">  ...: </span><br><span class="line">In[<span class="number">4</span>]: demo(<span class="number">5</span>)</span><br><span class="line">哈哈 -&gt; demo，结果为：1</span><br><span class="line">哈哈 -&gt; demo，结果为：2</span><br><span class="line">哈哈 -&gt; demo，结果为：6</span><br><span class="line">哈哈 -&gt; demo，结果为：24</span><br><span class="line">哈哈 -&gt; demo，结果为：120</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">120</span></span><br></pre></td></tr></table></figure>
<p>我觉得想要理解装饰器，这几个点是应该会的。</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><h4 id="爱生活，爱小丽"><a href="#爱生活，爱小丽" class="headerlink" title="爱生活，爱小丽"></a>爱生活，爱小丽</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/" data-id="cjfx9re5m000dj7fytsbhcsck" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python/Python-记学习对象可变性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Python/Python-记学习对象可变性/" class="article-date">
  <time datetime="2018-04-13T00:50:17.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Python/Python-记学习对象可变性/">Python-记学习对象可变性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在刚学Python的时候就知道元组是不可变的，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: id(t)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">4457650000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: t += (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: id(t)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">4456501496</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: t</span><br><span class="line">Out[<span class="number">5</span>]: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>当我们想要改变元组的时候他会新建一个对象来存储值，但是当我们的元组里有一个可变的对象呢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: t1 = ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], )</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: t1[<span class="number">0</span>].append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: t1</span><br><span class="line">Out[<span class="number">10</span>]: ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],)</span><br></pre></td></tr></table></figure>
<p>其实元组保存的只是对象的引用，如果元组里的元素可变那么元素就是可变的。这里说的不可变只是元组保存的引用不变</p>
<p>在说一下深拷贝、浅拷贝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: l1 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: l2 = list(l1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: l2</span><br><span class="line">Out[<span class="number">13</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: l2[<span class="number">1</span>].append(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: l2</span><br><span class="line">Out[<span class="number">15</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: l1</span><br><span class="line">Out[<span class="number">16</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: l1[<span class="number">-1</span>] += (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: l1</span><br><span class="line">Out[<span class="number">19</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: l2</span><br><span class="line">Out[<span class="number">20</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>
<p>list()方法默认做的是浅拷贝。浅拷贝就是只复制最外层的容器，复制出来容器里的元素仍为源容器中元素的引用。即<strong>l2的元素引用还是指向l1的</strong>，所以当l2[1]更改了的时候l1[1]也更改了。但是由于元组是不可变元素，所以当更改他的时候会新创建一个元组对象，所以l1和l2中的互不干扰</p>
<p>而深拷贝则不共享引用，全部重新创建新的引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: l3 = copy.deepcopy(l1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: l3</span><br><span class="line">Out[<span class="number">23</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: l1</span><br><span class="line">Out[<span class="number">24</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: l1[<span class="number">1</span>].append(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: l1</span><br><span class="line">Out[<span class="number">26</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">200</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: l3</span><br><span class="line">Out[<span class="number">28</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br></pre></td></tr></table></figure>
<p>接下来说方法形参问题，都知道形参是一个实参的引用。那么这个时候传不可变对象还好。如果传可变参的话，那么方法做的更改就会关系到方法外</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    ...:     a += b</span><br><span class="line">    ...:     <span class="keyword">return</span> a</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: y = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: f(x, y)</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: x</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>所以，尽量不要传递一个可变的对象给函数，除非你想这么做</p>
<p>同理，函数的默认参也不要是一个可变对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: bus1 = HauntedBus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="string">'Alice'</span>, <span class="string">'Bill'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: bus1.pick(<span class="string">'Charlie'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: bus1.drop(<span class="string">'Alice'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">36</span>]: [<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: bus2 = HauntedBus()</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: bus2.passengers</span><br><span class="line">Out[<span class="number">39</span>]: [<span class="string">'Carrie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: bus3 = HauntedBus()</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: bus3.passengers</span><br><span class="line">Out[<span class="number">41</span>]: [<span class="string">'Carrie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: bus3.pick(<span class="string">'Dave'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: bus3.passengers</span><br><span class="line">Out[<span class="number">43</span>]: [<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: bus2.passengers</span><br><span class="line">Out[<span class="number">44</span>]: [<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: bus2.passengers <span class="keyword">is</span> bus3.passengers</span><br><span class="line">Out[<span class="number">45</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">46</span>]: [<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br></pre></td></tr></table></figure>
<p>可以看到bus2和bus3共用了一组乘客，问题就是出在<code>self.passengers = passengers</code>，这里如果我们在创建对象时什么也不传则用了默认参<code>passengers=[]</code>，而默认参是在加载模块的时候定义，不会每次都创建，所以默认参是这个函数的属性，而这个属性是个可变对象的时候，那么修改了之后后续的都会受到影响</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><h4 id="爱生活，爱小丽"><a href="#爱生活，爱小丽" class="headerlink" title="爱生活，爱小丽"></a>爱生活，爱小丽</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Python/Python-记学习对象可变性/" data-id="cjfx9re5o000ej7fygxio1m6p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-ThreadLocal解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/10/Android/Android-ThreadLocal解析/" class="article-date">
  <time datetime="2017-04-10T12:20:00.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/10/Android/Android-ThreadLocal解析/">Android-ThreadLocal解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>ThreadLocal分析</strong></p>
<p>Handler的运行需要MessageQueue和Looper的支持，如果您对这方面不是很熟悉，那么我推荐您阅读<a href="http://www.jianshu.com/p/e6dec5f39d09" target="_blank" rel="noopener">这个</a>，或者看<strong>Android开发艺术探索</strong>，而为了更好的理解Looper，那么ThreadLocal是避不过去的一项</p>
<p>我们都知道，一个线程只能创建一个Looper，那么在这个线程中传递数据的就是ThreadLocal了</p>
<p>ThreadLocal是一个线程内部的数据存储类，他可以在指定的线程中存储数据，然后当然也只能在存储数据的线程来获取数据，来看一个小demo</p>
<p>首先我们定义一个ThreadLocal对象，然后分别在主线程和两个子线程中去设置数据和获取数据</p>
<pre><code>private ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;&gt;();

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mBooleanThreadLocal.set(true);
    Log.d(&quot;112233&quot;, Thread.currentThread().getName()
            + &quot; = &quot; + 
            mBooleanThreadLocal.get());

    new Thread(&quot;Thread #1&quot;){
        @Override
        public void run() {
            super.run();
            mBooleanThreadLocal.set(false);
            Log.d(&quot;112233&quot;, Thread.currentThread().getName()
                    + &quot; = &quot; + 
                    mBooleanThreadLocal.get());
        }
    }.start();

    new Thread(&quot;Thread #2&quot;){
        @Override
        public void run() {
            super.run();
            Log.d(&quot;112233&quot;, Thread.currentThread().getName()
                    + &quot; = &quot; + 
                    mBooleanThreadLocal.get());
        }
    }.start();
}
</code></pre><p>可以看到这里用的都是同一个LocalThread对象，然后运行程序，看一下log</p>
<pre><code>D/112233: main = true
D/112233: Thread #1 = false
D/112233: Thread #2 = null
</code></pre><p>我们会发现在不同的线程中获得的值是不同的，下面来分析一下源码，来看一下为什么返回的值不一样</p>
<pre><code>public T get() {
    Thread t = Thread.currentThread();//从这里获取当前线程
    ThreadLocalMap map = getMap(t);//这里获取当前线程的Map
    if (map != null) {
        //这里取出由当前threadLocal为key的entry
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null)
            return (T)e.value;//返回value
    }
    return setInitialValue();//如果为空，那么初始化
}

-------------------------------------------

ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;//这里返回多个threadLocal的对象
}

-------------------------------------------

private T setInitialValue() {
    T value = initialValue();//这个方法返回null
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);//如果map存在，则替换掉数据
    else
        createMap(t, value);//如果map不存在，则创建一个map，数据为null
    return value;//最后返回null
}
</code></pre><p>从get方法我们可以看得出来获取数据是用Thread为参数的，所以说每个线程的数据都不一样。既然这样我们就再来看看set方法</p>
<pre><code>public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre><p>我们会发现和上面的setInitialValue()方法差不多，都是调用的map.set()方法，这个方法其实就是一个以当前ThreadLocal为key存储的过程，我们就不细细的去研究了，有兴趣的可以去看一下</p>
<p>至此这个ThreadLocal我们也就研究的差不多了，其实的就是<strong>在不同的线程存储不同的数据</strong></p>
<hr>
<p><strong>ThreadLocal和InheritableThreadLocal</strong></p>
<p>我第一次写那个小demo的时候犯了一个小错误，new对象的时候new成了InheritableThreadLocal，从名字我们也可以看得出来这是一个继承了table的ThreadLocal，关于这两个有什么区别，我推荐您看<a href="http://blog.csdn.net/jiafu1115/article/details/7548605" target="_blank" rel="noopener">这个</a></p>
<hr>
<p><strong>爱小丽，爱Android</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2017/04/10/Android/Android-ThreadLocal解析/" data-id="cjfx9tx710003lpfyovwgenqo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-同向滑动冲突" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/09/Android/Android-同向滑动冲突/" class="article-date">
  <time datetime="2017-02-09T11:20:00.000Z" itemprop="datePublished">2017-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/09/Android/Android-同向滑动冲突/">Android-同向滑动冲突</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>惯例上图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-04a50bb5c151f136.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>好久没写文章了，最近弄了一个小需求，就是ScrollView里嵌套ListView，当然ListView是固定高度并且要求能上下滑动，而且在滑动到顶部或者底部的时候由ScrollView来拦截滑动事件。这也就是我们说的<strong>同向滑动冲突。</strong></p>
<h2 id="什么时候拦截？"><a href="#什么时候拦截？" class="headerlink" title="什么时候拦截？"></a>什么时候拦截？</h2><p>上面我们已经说了，<strong>滑动到顶部或者底部的时候拦截</strong></p>
<p><strong>如何判断已经滑动到了顶部或者底部？</strong></p>
<p>我们知道无论是ListView还是RecyclerView都是复用机制，啥是复用机制都不知道那我推荐你看看关于这类的文章。由于是复用，那么我们就不能直接用ListView.getChildAt(X)来获取，所以我们要根据系统提供给我们的方法来获取顶部和底部的View，然后通过这两个View来判断是否达到了顶部或者底部</p>
<p><strong>获取顶部和底部的View</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lv.setOnScrollListener(<span class="keyword">new</span> AbsListView.OnScrollListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从这里获取最后一个item的View和第一个item的View</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        lastView = view.getChildAt(totalItemCount - firstVisibleItem - <span class="number">1</span>);</span><br><span class="line">        firstView = view.getChildAt(firstVisibleItem);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>判断是否达到顶端或者底端</strong></p>
<pre><code>int action = motionEvent.getAction();
if (action == MotionEvent.ACTION_DOWN) {
    lastY = (int) motionEvent.getY();
} else if (action == MotionEvent.ACTION_MOVE) {
    /**
     * 这里判断是向下还是向上滑动
     */
    if (lastY &gt; motionEvent.getY()) {
        isDown = true;
        isUp = false;
    } else {
        isDown = false;
        isUp = true;
    }
}

if (lv != null) {
    if (firstView != null &amp;&amp; isUp) {
        /**
         * 如果ListView已经初始化并且firstView不为空
         * 而且不是第一次加载视图（因为第一次加载视图getTop肯定为0）并且向上滑动
         *
         */
        if (firstView.getTop() == 0) {
            flag = true;
        } else {
            flag = false;
        }
    }
    if (lastView != null &amp;&amp; isDown) {
        /**
         * 这里判断坐标，如果lastView的Bottom等于这个ListView的高度并且是往下滑
         * 则把flag设置为true，当然这里还有一个坑，因为ListView是固定高度，所以所有的item高度之和都没有达到ListView的高度，那么这个也需要判断一下
         */

        int childHeight = lv.getChildAt(0).getHeight();
        int childCount = lv.getChildCount();
        int totalChildHeight = childHeight * childCount;

        if ((lastView.getBottom()) == view.getHeight() || totalChildHeight &lt; view.getHeight()) {
            flag = true;
        } else {
            flag = false;
        }
        isFirst = false;
    }
}
</code></pre><p>这里我们还需要判断一下手势，达到了顶端并且是往上滑，达到了底部并且往下滑。</p>
<p>当然这里还有一个坑，那就是我们刚家在布局的时候getTop()是肯定等于0的，所以我们要判断一下是否是第一次加载</p>
<p>最后我们通过flag来判断一下是否让ScrollView来拦截事件</p>
<pre><code>/**
 * flag 为 true的时候 ScrollView开始获得事件
 */
if (flag &amp;&amp; !isFirst) {
    sv.requestDisallowInterceptTouchEvent(false);
} else {
    sv.requestDisallowInterceptTouchEvent(true);
}
</code></pre><p>这样一来也就结束了，放上全部代码</p>
<pre><code>public class MainActivity extends AppCompatActivity {

    List&lt;String&gt; mData;
    ListView lv;
    ArrayAdapter&lt;String&gt; adapter;
    ScrollView sv;
    boolean flag, isFirst = true;
    boolean isUp, isDown;
    int lastY;
    View lastView, firstView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mData = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            mData.add(&quot;ad &quot; + i);
        }

        tv1 = (TextView) findViewById(R.id.tv1);
        sv = (ScrollView) findViewById(R.id.sv);
        lv = (ListView) findViewById(R.id.lv);
        adapter = new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_expandable_list_item_1, mData);
        lv.setAdapter(adapter);

        lv.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View view, MotionEvent motionEvent) {
                sv.requestDisallowInterceptTouchEvent(true);

            int action = motionEvent.getAction();
            if (action == MotionEvent.ACTION_DOWN) {
                lastY = (int) motionEvent.getY();
            } else if (action == MotionEvent.ACTION_MOVE) {
                /**
                 * 这里判断是向下还是向上滑动
                 */
                if (lastY &gt; motionEvent.getY()) {
                    isDown = true;
                    isUp = false;
                } else {
                    isDown = false;
                    isUp = true;
                }
            }

            if (lv != null) {
                if (firstView != null &amp;&amp; isUp) {
                    /**
                     * 如果ListView已经初始化并且firstView不为空
                     * 而且不是第一次加载视图（因为第一次加载视图getTop肯定为0）并且向上滑动
                     *
                     */
                    if (firstView.getTop() == 0) {
                        flag = true;
                    } else {
                        flag = false;
                    }
                }
                if (lastView != null &amp;&amp; isDown) {
                    /**
                     * 这里判断坐标，如果lastView的Bottom等于这个ListView的高度并且是往下滑
                     * 则把flag设置为true
                     */

                    int childHeight = lv.getChildAt(0).getHeight();
                    int childCount = lv.getChildCount();
                    int totalChildHeight = childHeight * childCount;

                    if ((lastView.getBottom()) == view.getHeight() || totalChildHeight &lt; view.getHeight()) {
                        flag = true;
                    } else {
                        flag = false;
                    }
                    isFirst = false;
                }
            }


                /**
                 * flag 为 true的时候 ScrollView开始获得事件
                 */
                if (flag &amp;&amp; !isFirst) {
                    sv.requestDisallowInterceptTouchEvent(false);
                } else {
                    sv.requestDisallowInterceptTouchEvent(true);
                }


                return false;
            }
        });

        lv.setOnScrollListener(new AbsListView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(AbsListView view, int scrollState) {


            }


            @Override
            public void onScroll(AbsListView view, int firstVisibleItem,
                                 int visibleItemCount, int totalItemCount) {

                /**
                 * 从这里获取最后一个item的View和第一个item的View
                 */
                lastView = view.getChildAt(totalItemCount - firstVisibleItem - 1);
                firstView = view.getChildAt(firstVisibleItem);


            }
        });
    }
}
</code></pre><hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2017/02/09/Android/Android-同向滑动冲突/" data-id="cjfx9tx700002lpfyvem8wpl1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-MVP Demo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/20/Android/Android-MVP Demo/" class="article-date">
  <time datetime="2017-01-20T11:10:00.000Z" itemprop="datePublished">2017-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/20/Android/Android-MVP Demo/">Android-MVP Demo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>引用<a href="http://rocko.xyz/" target="_blank" rel="noopener">Rocko</a>说过的一段话</p>
<blockquote>
<p>MVP作为一种MVC的演化版本在Android开发中受到了越来越多的关注，但在项目开发中选择一种这样的软件设计模式需保持慎重心态，一旦确定使用MVP作为你App的开发模式那么你就最好坚持做下去，如果在使用MVP模式开发过程中发现问题而且坑越来越大，这时你想用MVC等来重新设计的话基本上就等于推倒重来了。要知道在Android上MVP在现在为止并没有统一的标准或者框架，不像SSH这三个成熟稳重强而有力的三剑客支持推动着Java EE的开发，所以在运用MVP时一定要做好自己的理解，并且尽量预知自己App各模块的需求以便提前做好充分的设计工作。</p>
</blockquote>
<p>其实关于MVP的文章已经很多了，我觉得我再去说一些理论性的东西显得有点“老套”，所以我直接上一个小的项目（知乎日报）。关于理论知识这里推荐两篇文章，我也是按照这个来自己学习的。仔细想一想，多写一写。</p>
<p><a href="http://www.jianshu.com/p/9a6845b26856" target="_blank" rel="noopener">Android MVP 详解（上）</a></p>
<p><a href="http://www.jianshu.com/p/0590f530c617" target="_blank" rel="noopener">Android MVP 详解（下）</a></p>
<h2 id="关于知乎日报的实现"><a href="#关于知乎日报的实现" class="headerlink" title="关于知乎日报的实现"></a>关于知乎日报的实现</h2><blockquote>
<p>我的MVP学的还不是很到位，所以有出错的地方请各位指正</p>
</blockquote>
<p><strong>MVP实现的是View和Model的解耦，View中只需要实现接口来接收数据显示界面即可</strong></p>
<p>所以，当我们开始写一个界面的时候，我们就应该想这个界面需要“哪些数据”？我们就根据这个想法来定义接口，至于处理数据/提供数据就交给Presenter去处理。</p>
<p>知乎日报大家都熟悉，我这里只写了一个首页，应该说很简单。</p>
<p>如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-bae3ec4f9c9b9fbc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>然后看一下工程的目录，如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-64923baa8792aa17.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>model就是我们的数据了，presenter就是我们的中间层，来处理数据，至于ui就更不用说了，我们的activity、fragment等都放在这。</p>
<p>首先我们要构思一下，这个页面需要什么？</p>
<ul>
<li>banner</li>
<li>ListView的数据</li>
<li>拉倒最后加载更多的数据</li>
<li>加载失败的回调</li>
</ul>
<p>根据这几个我们就可以定义出来一个view的接口<code>IZhiHuFgView</code>，接口如下：</p>
<pre><code>public interface IZhiHuFgView {
    /**
     * 加载的的数据
     */
    void setStories(List&lt;Stories&gt; stories);

    /**
     * 设置banner的View
     */
    void setBanner(View bannerView);

    /**
     * 出错
     */
    void onError();
}
</code></pre><p>然后我们的<code>ZhiHuFragment</code>来实现这个接口，实现这些方法就可以来添加数据了</p>
<pre><code>public class ZhiHuFragment extends Fragment implements IZhiHuFgView, AbsListView.OnScrollListener, SwipeRefreshLayout.OnRefreshListener {

    @Bind(R.id.stories_list)
    ListView storiesList;
    @Bind(R.id.refresh_view)
    SwipeRefreshLayout refreshView;

    /**
     * 持有presenter的对象来处理数据
     */
    private IZhiHuFgPresenter zhiHuFgPresenter;
    private List&lt;Stories&gt; stories;
    private StoriesAdapter storiesAdapter;
    private boolean isRequest = false;

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = LayoutInflater
                .from(getContext())
                .inflate(R.layout.fragment_zhihu, container, false);
        ButterKnife.bind(this, view);

        init();
        return view;
    }

    /**
     * 初始化一些view
     */
    private void init() {
        zhiHuFgPresenter = new ZhiHuFgPresenter(getActivity(), this);
        storiesAdapter = new StoriesAdapter(getContext());
        storiesList.setAdapter(storiesAdapter);
        stories = new ArrayList&lt;&gt;();

        refreshView.setColorSchemeColors(
                getActivity().getResources().getColor(R.color.colorPrimary));
        refreshView.post(new Runnable() {
            @Override
            public void run() {
                refreshView.setRefreshing(true);
            }
        });
        refreshView.setOnRefreshListener(this);
        storiesList.setOnScrollListener(this);
        zhiHuFgPresenter.getZhiHuStories();

    }

    /**
     * 设置加载的数据
     */
    @Override
    public void setStories(List&lt;Stories&gt; stories) {
        isRequest = false;
        this.stories.addAll(stories);
        storiesAdapter.setData(this.stories);

        refreshView.post(new Runnable() {
            @Override
            public void run() {
                refreshView.setRefreshing(false);
            }
        });
    }

    /**
     * 设置banner
     */
    @Override
    public void setBanner(View bannerView) {
        storiesList.addHeaderView(bannerView);
    }


    /**
     * 出错
     */
    @Override
    public void onError() {
        Toast.makeText(getContext(), &quot;error&quot;, Toast.LENGTH_SHORT).show();
    }

    /**
     * 加载更多滑动监听
     */
    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {
        if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE
                &amp;&amp; view.getLastVisiblePosition() == (view.getCount() - 1) &amp;&amp; !isRequest) {
            isRequest = true;
            zhiHuFgPresenter.getBeforeStories();
        }
    }

    @Override
    public void onScroll(AbsListView absListView, int i, int i1, int i2) {

    }

    /**
     * 刷新
     */
    @Override
    public void onRefresh() {
        stories.clear();
        zhiHuFgPresenter.getZhiHuStories();
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        ButterKnife.unbind(this);
    }

}
</code></pre><p>可以清楚的看到，我们的<strong>view层只是用来展示数据</strong>，调理是不是清晰了很多，剩下的就是用presenter这个中间层来处理数据回调给view层了，代码很简单，就不贴了，有需要的可以移步<a href="https://github.com/wanglu1209/ZhiHuDaily_MVP" target="_blank" rel="noopener">GitHub</a>查看详细代码</p>
<hr>
<h2 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h2><p>MVP最大的好处就是View和Model的解耦，方便单元测试等。但是代码量很多，会创建出很多的View层接口。</p>
<p>我觉得写MVP的一个难点就是在于抽离，要思考这个页面需要什么，然后设计成接口</p>
<p>文笔不佳，抱歉了各位</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2017/01/20/Android/Android-MVP Demo/" data-id="cjfx9tx6q0000lpfyspszfiyz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-RecyclerView拖拽排序和删除" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/10/Android/Android-RecyclerView拖拽排序和删除/" class="article-date">
  <time datetime="2017-01-10T10:20:00.000Z" itemprop="datePublished">2017-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/10/Android/Android-RecyclerView拖拽排序和删除/">Android-RecyclerView拖拽排序和删除</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://upload-images.jianshu.io/upload_images/1822424-1c7186c79c7c3176.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h3 id="ItemTouchHelper"><a href="#ItemTouchHelper" class="headerlink" title="ItemTouchHelper"></a>ItemTouchHelper</h3><p>最近看其他项目中总会看到这个效果，『拖拽排序，拖拽删除』，其实这个效果放在以前的话是比较难做的，现在Google在support-v7包中添加了这个Helper，使得现在做这个效果很简单</p>
<p>可以看到我工程名字起的就是RecyclerViewDrag，所以就可以看的出来这个Helper是和RecyclerView一起工作的，从Google官方文档我们也可以看到这样两句话：</p>
<p>『This is a utility class to add swipe to dismiss and drag &amp; drop support to RecyclerView.』</p>
<p>『Depending on which functionality you support, you should override onMove(RecyclerView, ViewHolder, ViewHolder) and / or onSwiped(ViewHolder, int).』</p>
<p>大致意思就是这个工具类可以支持RecyclerView的拖拽和消除，根据你的需求应该要重写onMove或者onSwiped这两个方法，所以根据剧情需要，我们来重写这两个方法。</p>
<p>但是在重写这两个方法之前我们首先应该看一下onMove()和onSwiped()这两个方法，而这两个方法是在ItemTouchHelper的内部类Callback中，所以我们跟进官方文档，可以看到下面这段话：</p>
<p>『If user drags an item, ItemTouchHelper will call onMove(recyclerView, dragged, target). Upon receiving this callback, you should move the item from the old position (dragged.getAdapterPosition()) to new position (target.getAdapterPosition()) in your adapter and also call notifyItemMoved(int, int)』</p>
<p>这么长一大段，我以小学英语水平大致看了一下，差不多的意思就是说『如果用户拖动了某一个Item，那么就会回调onMove这个方法，而在收到这个回调的时候我们应该让RecyclerView做一些事情，比如从旧的位置(dragged.getAdapterPosition())到新的位置（target.getAdapterPosition()），然后在你的adapter中调用notifyItemMoved(int, int)方法』</p>
<p><strong>大致就是这个意思，反正我看不太懂</strong></p>
<p>所以我们应该能有点思路，就是拖动的时候要回调onMove()方法，然后我们根据这个方法来回调参数进行我们的操作，这首先就想到了接口，所以我们定义一个接口：</p>
<pre><code>public interface OnItemCallbackListener {
    /**
     * @param fromPosition 起始位置
     * @param toPosition 移动的位置
     */
    void onMove(int fromPosition, int toPosition);
    void onSwipe(int position);
}
</code></pre><p>然后在onMove()/onSwiped()方法中回调</p>
<pre><code>/**
 * Item是否能被Swipe到dismiss
 * 也就是删除这条数据
 */
@Override
public boolean isItemViewSwipeEnabled() {
    return true;
}

/**
 * Item长按是否可以拖拽
 */
@Override
public boolean isLongPressDragEnabled() {
    return true;
}

/**
 * 设置Drag/Swipe的Flag
 * 这里我们把滑动(Drag)的四个方向全都设置上了,说明Item可以随意移动
 * 然后把删除(暂且叫删除/swipe)的方向设置为Start和End,说明可以水平拖动删除
 */
@Override
public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
    int dragFlag = ItemTouchHelper.LEFT | ItemTouchHelper.DOWN | ItemTouchHelper.UP | ItemTouchHelper.RIGHT;
    int swipeFlag = ItemTouchHelper.START | ItemTouchHelper.END;

    return makeMovementFlags(dragFlag, swipeFlag);
}

@Override
public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {
    /**
     * 回调
     */
    adapter.onMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());
    return true;
}

@Override
public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
    /**
     * 回调
     */
    adapter.onSwipe(viewHolder.getAdapterPosition());
}
</code></pre><p>然后我们定义一个自己的adapter来实现这个接口，代码如下：</p>
<pre><code>public class MyAdapter extends  RecyclerView.Adapter&lt;MyAdapter.Holder&gt; implements OnItemCallbackListener{

    private List&lt;String&gt; mData;
    private Context mContext;

    public MyAdapter(Context mContext) {
        this.mContext = mContext;
        mData = new ArrayList&lt;&gt;();
        mData.add(&quot;one&quot;);
        mData.add(&quot;two&quot;);
        mData.add(&quot;three&quot;);
        mData.add(&quot;four&quot;);
        mData.add(&quot;five&quot;);
        mData.add(&quot;six&quot;);
        mData.add(&quot;seven&quot;);
    }

    @Override
    public Holder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(mContext).inflate(R.layout.adapter_test, parent, false);
        return new Holder(view);
    }

    @Override
    public void onBindViewHolder(final Holder holder, int position) {
        holder.tv.setText(mData.get(position));
    }

    @Override
    public int getItemCount() {
        return mData.size();
    }

    @Override
    public void onMove(int fromPosition, int toPosition) {
        /**
         * 在这里进行给原数组数据的移动
         */
        Collections.swap(mData, fromPosition, toPosition);
        /**
         * 通知数据移动
         */
        notifyItemMoved(fromPosition, toPosition);
    }

    @Override
    public void onSwipe(int position) {
        /**
         * 原数据移除数据
         */
        mData.remove(position);
        /**
         * 通知移除
         */
        notifyItemRemoved(position);
    }

    class Holder extends RecyclerView.ViewHolder {
        TextView tv;
        public Holder(View itemView) {
            super(itemView);
            tv = (TextView) itemView.findViewById(R.id.tv);
        }
    }
}
</code></pre><p>最后在Activity中：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    RecyclerView rv = (RecyclerView) findViewById(R.id.rv);
    rv.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));

    final MyAdapter adapter = new MyAdapter(this);
    rv.setAdapter(adapter);

    ItemTouchHelper.Callback callback = new OnItemCallbackHelper(adapter);

    /**
     * 实例化ItemTouchHelper对象,然后添加到RecyclerView
     */
    ItemTouchHelper helper = new ItemTouchHelper(callback);
    helper.attachToRecyclerView(rv);
}
</code></pre><p>这样一个最简单的拖拽滑动、删除的效果就完成了，其实还可以设置RecyclerView的其他LayoutManager，这里就不过多做解释了，有兴趣的可以试试</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2017/01/10/Android/Android-RecyclerView拖拽排序和删除/" data-id="cjfx9tx6w0001lpfyxj65lr2s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义banner实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/20/Android/Android-自定义banner实现/" class="article-date">
  <time datetime="2016-11-20T13:15:00.000Z" itemprop="datePublished">2016-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/20/Android/Android-自定义banner实现/">Android-自定义banner实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>惯例先上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-f438927e8fb53ae2.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>可以看到这是一个轮播图，只不过我们以前在用的时候一般都是用ViewPager，用正常的ViewPager有几点坏处：</p>
<ul>
<li>不能无限循环</li>
<li>不能控制自动播放</li>
</ul>
<p>所以这就需要自己封装一个了，其实还是用的ViewPager，只不过更改了他的触摸事件并且设置了自动轮播的时间，然后自己写了一个PagerAdapter来实现无限轮播，最后下面的指示器和ViewPager、PagerAdapter封装到了一起，所以使用的时候很简单。<strong>只需要继承自BannerPagerAdapter，重写构造和setView()方法。然后在使用的时候调用方法即可</strong>，基本代码如下：</p>
<pre><code>List&lt;Integer&gt; data = new ArrayList&lt;&gt;();
data.add(R.mipmap.a1);
data.add(R.mipmap.a2);
data.add(R.mipmap.a3);
data.add(R.mipmap.a4);


AdapterDemo ad = new AdapterDemo(this, data);

Banner banner = (Banner) findViewById(R.id.banner);

/**
 * 关于这里的设置参数问题,是需要这样使用的
 * 在设置了小圆点之后才能设置适配器
 * 因为只有在适配器里才会根据一共多少条数据来适配
 * 最后需要调用开始轮播
 * 个人建议在onPause()/onDestroy()方法中来停止 -- stopAutoPlay()
 */
banner.setDot(R.drawable.no_selected_dot, R.drawable.selected_dot).
    setDotGravity(Banner.CENTER).
    setAdapter(ad).
    setOnItemClickListener(new BannerPagerAdapter.onItemClickListener() {
        @Override
        public void onClick(int position) {
            Toast.makeText(MainActivity.this, &quot;&quot; + position, Toast.LENGTH_SHORT).show();
        }
    }).
    startAutoPlay(); 
</code></pre><p>下面是AdapterDemo的代码：</p>
<pre><code>public class AdapterDemo extends BannerPagerAdapter {

    private Context mContext;
    private List&lt;Integer&gt; data;

    public AdapterDemo(Context context, List data) {
        super(context, data);
        mContext = context;
        this.data = data;
    }

    /**
     * 只需要重写构造和这个方法即可
     * 在这里可以设置自己的View,使用自己的图片加载库
     */
    @Override
    public View setView(int position) {
        View v = LayoutInflater.from(mContext).inflate(R.layout.test, null);
        ImageView iv = (ImageView) v.findViewById(R.id.iv);
        iv.setImageResource(data.get(position));
        return v;
    }
}
</code></pre><p>可以看的出来这里给调用者很大的空间来进行自己的操作，在setView中直接可以根据position来设置自己的View和数据，<strong>并且使用自己的图片加载库。</strong></p>
<p>如果感兴趣的可以移步<a href="https://github.com/wanglu1209/Banner" target="_blank" rel="noopener">GitHub</a></p>
<hr>
<p><strong>下面开始说如何写</strong></p>
<p>首先我们要确定一下这个banner有几个需要注意的点：</p>
<ol>
<li>无限轮播</li>
<li>点击事件</li>
<li>指示器</li>
<li>指示器的滑动效果</li>
</ol>
<h3 id="无限轮播、点击事件"><a href="#无限轮播、点击事件" class="headerlink" title="无限轮播、点击事件"></a>无限轮播、点击事件</h3><p>关于无限轮播，我参照的是任玉刚大神的博客，所以我也希望各位去看这个博客，也算是涨点人气，我这里就不写到底如何实现的了，各位可以查看我的代码</p>
<p><a href="http://blog.csdn.net/singwhatiwanna/article/details/46541225" target="_blank" rel="noopener">循环广告位组件的实现 – 任玉刚</a></p>
<h3 id="指示器、滑动效果"><a href="#指示器、滑动效果" class="headerlink" title="指示器、滑动效果"></a>指示器、滑动效果</h3><p>其实我写的时候有好多坑，但是写这篇文章的时候感觉都不是特别难的点（<strong>技术太菜</strong>）</p>
<p>关于指示器，其实现在大部分都是小圆点，这里我实现的思路是创建一个FrameLayout来添加ViewPager和指示器</p>
<p>但是可以看到，这里的指示器会有一个随着页面滑动而滑动的效果，这里就需要两层了，<strong>一个是包含未选中的，一个是包含了选中和未选中的（Group）</strong></p>
<p>代码如下：</p>
<pre><code>private void init() {
    mPager = new BannerViewPager(mContext);
    addView(mPager);
    /**
     * 实例化两个Group
     */
    mFrameLayout = new FrameLayout(mContext);
    mDotGroup = new LinearLayout(mContext);
    /**
     * 设置小圆点Group的方向为水平
     */
    mDotGroup.setOrientation(LinearLayout.HORIZONTAL);
    /**
     * 如果不设置则小圆点在中间
     */
    mDotGroup.setGravity(CENTER | Gravity.BOTTOM);
    /**
     * 两个Group的大小都为match_parent
     */
    LinearLayout.LayoutParams params =
            new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT);
    /**
     * 首先添加小圆点的Group
     */
    mFrameLayout.addView(mDotGroup, params);
    /**
     * 然后添加包含的Group（f**k,表达能力有限）
     */
    addView(mFrameLayout, params);

    /**
     * 添加到任务栈,当前所有任务完事之后添加已经选中的那个小圆点
     */
    post(new Runnable() {
        @Override
        public void run() {
            ImageView iv = new ImageView(mContext);
            iv.setImageDrawable(mContext.getResources().getDrawable(mDot[1]));
            FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            /**
             * 设置选中小圆点的左边距
             */
            params.leftMargin = (int) mDotGroup.getChildAt(0).getX();
            params.gravity = Gravity.BOTTOM;
            mFrameLayout.addView(iv, params);
            mSelectedDot = mFrameLayout.getChildAt(1);
        }
    });
    mPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            /**
             * 获取到当前position
             */
            position %= mAdapter.size;
            /**
             * 判断如果当前的position不是最后一个,那么就设置偏移量来实现被选中小圆点的滑动效果
             */
            if (mSelectedDot != null &amp;&amp; position != mAdapter.size -1) {
                float dx = mDotGroup.getChildAt(1).getX() - mDotGroup.getChildAt(0).getX();
                mSelectedDot.setTranslationX((position * dx) + positionOffset * dx);
            }
        }

        @Override
        public void onPageSelected(int position) {
            position %= mAdapter.size;
            /**
             * 如果已经是最后一个,那么则直接把小圆点定位到那,不然滑动效果会出错
             */
            if (mSelectedDot != null &amp;&amp; position == mAdapter.size - 1) {
                float dx = mDotGroup.getChildAt(1).getX() - mDotGroup.getChildAt(0).getX();
                mSelectedDot.setTranslationX(position * dx);
            }
        }

        @Override
        public void onPageScrollStateChanged(int state) {

        }
    });

}
</code></pre><p>可以看到我们首先添加了ViewPager，然后我们添加了未选中指示器的Group，之后我们才添加的选中的指示器。在添加选中指示器的时候用了一个post，这个方法是把runnable里的代码添加到任务栈，前面的任务结束了这个任务才会执行，所以我们可以获取到第一个未选中小圆点的坐标，然后把选中指示器覆盖上去，后来我们移动的时候就直接移动选中的指示器就好了。</p>
<p>关于滑动指示器，其实就是用了一个setTranslationX()方法，这个方法可以虽然移动View的位置，但是没有真正的移动该View，所以我们在移动的时候根据position来计算，但是当移动到最后一个的时候就不应该用这个方法了，如果还用的话就会造成一种『出界』了的感觉，所以这里在最后一个的时候不进入方法。</p>
<p>有人应该会想到『在第一页的时候』，这里我们大家可以自己测试一下，当手指向右滑的时候，就已经是size-1页了，所以我们直接就用一个判断就够了</p>
<p><strong>额，写的乱七八糟，但是代码会说话的~</strong></p>
<p><strong>还是那句话，感兴趣的请移步GitHub哟~</strong></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2016/11/20/Android/Android-自定义banner实现/" data-id="cjfx9re5e0008j7fya0yflrn3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-各种情况下的『自动加载更多』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/10/Android/Android-各种情况下的『自动加载更多』/" class="article-date">
  <time datetime="2016-10-10T13:15:00.000Z" itemprop="datePublished">2016-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/10/Android/Android-各种情况下的『自动加载更多』/">Android-各种情况下的『自动加载更多』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在写项目的时候总是会碰到上拉自动加载更多这个需求，但是又不想用PullToRefresh，其实我们可以直接判断出来是否已经滑动到底端，如果滑动到底端则加载。一般的需求有在ScrollView、RecyclerView、ListView中自动加载</p>
<h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><p>在RecyclerView中判断是否滑动到底部，其实就是判断是否已经达到了<strong>最后一个可见的item &amp;&amp; 滑动结束</strong>，伪代码如下</p>
<pre><code>RecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
    @Override
    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
        if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; 
            (layoutManager.findLastVisibleItemPosition() == 
            layoutManager.getItemCount() - 1)
            &amp;&amp; !isRefreshing) {
            isRefreshing = true;         
            //处理逻辑
        }
    }
});
</code></pre><p>解释一下上面的判断，当状态为SCROLL_STATE_IDLE(停止滑动)时，并且目前可见的最后一个item的位置为总数-1，并且当前不在刷新状态中（<strong>因为有的时候需要网络请求，所以可能滑动到底部后一直请求接口，定义一个变量来判断一下</strong>），然后就可以处理逻辑了</p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>关于ListView的滑动底部监听其实和RecyclerView的判断差不多，代码如下：</p>
<pre><code>ListView.setOnScrollListener(new OnScrollListener() {
            @Override
            public void onScrollStateChanged(AbsListView view, int scrollState) {

                    if((scrollState == OnScrollListener.SCROLL_STATE_IDLE) &amp;&amp;
                            view.getLastVisiblePosition() == (view.getCount() - 1)
                            &amp;&amp; !isRefreshing) {
                        //处理逻辑
                    }
                }
            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem,
                                 int visibleItemCount, int totalItemCount) {
            }
        });   
</code></pre><p>ListView和RecyclerView差不多，就不多做解释了    </p>
<h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><p>最后关于ScrollView滑动到底部，因为<strong>ScrollView没有停止滑动的监听，所以使用要慎重！</strong></p>
<p>如果想要使用ScrollView来监听，那就要重写ScrollView，代码如下：</p>
<pre><code>onScrollBottomListener bottomListener;

public void setOnScrollBottomListener(onScrollBottomListener bottomListener){
    this.bottomListener = bottomListener;
}

public interface onScrollBottomListener{
    void onBottom();
}

@Override
protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);
    if(getHeight() + getScrollY() &gt;= getChildAt(0).getMeasureHeight()){
        if(bottomListener != null){
            bottomListener.onBottom();
        }
    }
}    
</code></pre><p>看的出来，我们定义了一个接口来回调，因为ScrollView里只能包含一个布局，所以可以根据这个特性来判断，所以在滑动事件监听里获取到当前ScrollView的高度和Y轴的滑动值的相加来和ScrollView包含的布局的高度来进行对比，如果大于的话那么就等于滑动到底部（<strong>但是这个方法会调用好多次</strong>）    </p>
<hr>
<p>以前工作的时候碰到过这些需求，当时在网上找也没有找到合适的（<strong>确实当时技术很菜</strong>），过了好久了，分享出来，希望后来又有需求的少碰坑- -</p>
<p>当然可以在布局的后面加一个FooterView，加载数据的时候显示『正在加载…』，加载到没有数据的时候显示一个『- end -』之类的</p>
<p>没写Demo，有兴趣的可以自己试试啦~</p>
<p>洗洗睡了，凌晨1:05</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2016/10/10/Android/Android-各种情况下的『自动加载更多』/" data-id="cjfx9re590006j7fyvc4f1x37" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-Android性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/10/Android/Android-Android性能优化/" class="article-date">
  <time datetime="2016-09-10T14:30:00.000Z" itemprop="datePublished">2016-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/10/Android/Android-Android性能优化/">Android-Android性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>其实关于性能优化这个我也只是学到个皮毛，我是按照书上说的加上自己理解的来写，<strong>如果有不对的地方，请指正，我也是个菜鸟。谢谢</strong></p>
</blockquote>
<p>Android性能的优化主要分为两点</p>
<ol>
<li>布局优化</li>
<li>内存优化</li>
</ol>
<h2 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h2><p>首先来看一下布局优化，系统在渲染UI的时候会消耗大量的资源，所以，对布局的优化就显得尤为重要</p>
<h4 id="避免Overdraw"><a href="#避免Overdraw" class="headerlink" title="避免Overdraw"></a>避免Overdraw</h4><p>也就是避免过度的绘制，过度的绘制会浪费更多的资源，<strong>举个例子，Android系统会默认绘制Activity的背景，这时候我们再设置一个背景，这样默认的背景就属于过度绘制了，</strong>在『开发者工具』中有一个『调试GPU过度绘制』的选项，我们打开就可以通过颜色来判断过度绘制的次数，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-0cf8e3b06aa8b4ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>所以说我们尽可能的<strong>增大蓝色区域，减少红色区域</strong></p>
<h4 id="优化布局层级"><a href="#优化布局层级" class="headerlink" title="优化布局层级"></a>优化布局层级</h4><p>在Android系统中，系统对View进行测量、布局、绘制的时候，都是通过对View树的遍历来进行的，所以说<strong>一个布局的层级太多，就会严重影响测量、布局、绘制的速度，所以要降低View树的高度，Google在文档中建议布局的层级不超过10层，所以还要避免嵌套没有用的布局</strong></p>
<h4 id="使用include标签"><a href="#使用include标签" class="headerlink" title="使用include标签"></a>使用include标签</h4><p>相信大家都会在项目的时候遇到toolbar，或者一个UI在多个界面使用的问题，遇到这种问题的时候我们一般都会用include（毕竟郭神『第一行代码』教的好），这样就减少了代码冗余，而且还利于后期更改</p>
<h4 id="使用ViewStub实现View的延时加载"><a href="#使用ViewStub实现View的延时加载" class="headerlink" title="使用ViewStub实现View的延时加载"></a>使用ViewStub实现View的延时加载</h4><p>ViewStub标签和View.GONE的方式差不多，但是ViewStub只会在显示的时候去渲染，而GONE在初始化的时候就已经渲染完毕了，所以相比来说ViewStub的效率更高。下面来通过代码使用一下ViewStub</p>
<p>首先我们定义一个布局文件</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/tv&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>这里面只放了一个TextView，然后我们在自己的布局中通过ViewStub来引用他</p>
<pre><code>&lt;Button
   android:id=&quot;@+id/btn&quot;
   android:layout_width=&quot;wrap_content&quot;
   android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;ViewStub
   android:id=&quot;@+id/vs&quot;
   android:layout_width=&quot;wrap_content&quot;
   android:layout_height=&quot;wrap_content&quot;
   android:layout=&quot;@layout/view_stub&quot;/&gt;
</code></pre><p>这里的逻辑是点击按钮然后出现ViewStub引用的布局（也就是我们上面写的那个布局文件）</p>
<pre><code>findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        ViewStub vs = (ViewStub) findViewById(R.id.vs);
        View vsView = vs.inflate();
        TextView tv = (TextView) vsView.findViewById(R.id.tv);
        tv.setText(&quot;hahaha&quot;);

    }
});
</code></pre><p>这里想要把ViewStub引用的布局显示出来有两种办法，一种是ViewStub.setVisibility();另一种就是ViewStub.inflate();这两种方法的区别就是inflate()能返回引用的布局，然后可以通过这个布局来找到里面的子View来进行操作</p>
<p>运行程序点击按钮，就可以看到TextView已经显示出来了，并且已经赋值『hahaha』</p>
<h4 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h4><p>这个工具可以显示我们的布局，但是只可以在模拟器和工厂的Demo机上用，不过Google的大神提供了一个开源的项目ViewServer，有兴趣的可以看一下，地址：<a href="https://github.com/romainguy/ViewServer" target="_blank" rel="noopener">ViewServer</a></p>
<p>这个就不过多阐述了，有兴趣的可以自行查看一下相关的资料</p>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>我们都知道，最近Android的厂商就是在拼配置，其中我们最关注的就是内存几个G，但是Android手机有的内存很大，但是很卡，这是因为有的手机软件在手机内存低的情况下不能被杀死，也就是我们说的『防杀』</p>
<p>我们知道内存一般分为这几个部分</p>
<ul>
<li>寄存器</li>
<li>栈</li>
<li>堆</li>
<li>静态存储区</li>
<li>常量池</li>
</ul>
<p>其中寄存器运算速度最快，但是我们在程序里无法控制</p>
<p>栈里存放基本数据类型</p>
<p>堆里存放对象和数组，在堆中的一般由Java的GC还管理</p>
<p>静态存储区在固定的位置存放应用程序中运行时一直存在的数据，Java专门划分了一个区域来管理静态变量</p>
<p>常量池就是该类型所使用到的常量的集合</p>
<h4 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h4><p>我们都知道在Android中是造成OOM的最大威胁，因为它占用的内存特别多，所以我们应该：</p>
<ul>
<li>使用适当分辨率大小的图片<ul>
<li>由于Android在做适配的时候会对不同分辨率的文件夹下的图片来进行缩放适配，如果图片的分辨率与资源分辨率不匹配的话就会导致消耗更多的资源</li>
</ul>
</li>
<li>使用缓存<ul>
<li>一般有内存缓存和硬盘缓存</li>
</ul>
</li>
</ul>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul>
<li>对常量使用static</li>
<li>使用静态方法，静态方法比普通方法提高15%左右的访问速度</li>
<li>减少没有必要的成员变量，如果能定义成局部变量就最好定义成局部变量</li>
<li>减少不必要的对象</li>
<li>少用枚举、迭代器</li>
<li>对Cursor、Receiver、File等对象，要注意回收和取消注册</li>
<li>使用SurfaceView来代替View进行大量并且频繁的绘图操作</li>
<li>尽量使用视图缓存，不是每次都执行inflate()来解析视图</li>
<li>避免使用反射</li>
<li>使用RenderScript、OpenGL来进行非常复杂的绘图操作</li>
</ul>
<p>以上就是对Android性能优化的一些点，如果你用AndroidStudio的话，AndroidStudio提供了一个内存监视的工具，还是很好用的，如果你没用AndroidStudio，那么我建议你使用AndroidStudio~</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2016/09/10/Android/Android-Android性能优化/" data-id="cjfx9re500003j7fywfn157hb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义控件PickerView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/20/Android/Android-自定义控件PickerView/" class="article-date">
  <time datetime="2016-08-20T04:15:00.000Z" itemprop="datePublished">2016-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/20/Android/Android-自定义控件PickerView/">Android-自定义控件PickerView</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间在公司总是有需求『滚动的选择器』，那时候总是用别人写好的来用，感觉心里不是很舒服，最近有时间了自己来写一写，上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-6d1e3f570799130a.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>首先分析一下需求：</p>
<ol>
<li>可以滑动</li>
<li>滑到两条线里的数据变色</li>
<li>滑动完成后必须要把选中的数据放到中间</li>
</ol>
<h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><p>首先说到滑动而且还是自定义的View，我们就会想到各种『scrollBy/scrollTo』等，但是这里有个更简单的方法就是<strong>继承自ScrollView</strong>，这样就简单了不少，并且还有滚动的监听『只不过少了一个停止滑动的状态』，然而对于这个需求，我们只需要创建一个ViewGroup来放入数据（也就是很多TextView），然后addView()就OK，代码如下：</p>
<pre><code>/**
 * 初始化数据,首先添加Group
 */
mTextGroup = new LinearLayout(context);
mTextGroup.setOrientation(LinearLayout.VERTICAL);
mTextGroup.setGravity(Gravity.CENTER);
addView(mTextGroup);


/**
 * 由于我们需要给自身的数据在选中的框里显示
 * 所以这里需要添加前面和后面的空数据
 */
mTextGroup.addView(createTextView(&quot;&quot;));
for (int i = 0; i &lt; mData.size(); i++) {
    mTextGroup.addView(createTextView(&quot;&quot; + mData.get(i)));
}
mTextGroup.addView(createTextView(&quot;&quot;));

------------------------------------------------------------

/**
 * 动态创建TextView
 */
private TextView createTextView(String s) {
    TextView tv = new TextView(context);
    tv.setText(s);
    tv.setTextColor(getResources().getColor(android.R.color.darker_gray));
    tv.setTextSize(mTextSize);
    LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, mTextHeight);

    params.bottomMargin = mTextHeight / 2;
    params.topMargin = mTextHeight / 2;
    tv.setLayoutParams(params);
    return tv;
}
</code></pre><p>可以看到我们在数据的前后都加了两条空数据，因为这里需要在滑动到底部或者顶部的时候确保第一条或者最后一条数据是在我们的两条线之内，这样运行一下程序就会发现我们的数据已经可以滑动了，只不过这个时候还没有中间的两条线。这里需要思考一下，如果我们添加两条线上去的话，滑动的时候线也会跟着滑动，所以这个时候就想到了背景，我们自己来画一个背景。代码如下：</p>
<pre><code>/**
 * 设置背景,这里选择画一个,两条线
 */
setBackground(new Drawable() {
    @Override
    public void draw(Canvas canvas) {
        /**
         * 这里把两条线之间的距离设置为了两个TextView的高度
         */
        canvas.drawLine(
                mWidth * 0.1f,
                mHeight / 2 - mTextHeight,
                mWidth * 0.9f,
                mHeight / 2 - mTextHeight,
                mLinePaint
        );
        canvas.drawLine(
                mWidth * 0.1f,
                mHeight / 2 + mTextHeight,
                mWidth * 0.9f,
                mHeight / 2 + mTextHeight,
                mLinePaint
        );
    }

    @Override
    public void setAlpha(int i) {

    }

    @Override
    public void setColorFilter(ColorFilter colorFilter) {

    }

    @Override
    public int getOpacity() {
        return 0;
    }
});
</code></pre><p>这时候我们的背景和数据都弄好了</p>
<h3 id="在线内的数据变颜色"><a href="#在线内的数据变颜色" class="headerlink" title="在线内的数据变颜色"></a>在线内的数据变颜色</h3><p>先考虑一下，因为我们使用的是TextView，所以我们直接就可以设置TextView的字体颜色。很简单，我们在onScrollChanged()方法中用小学除法来算一下当前滚动到了哪个TextView『也就是position』，我们就把哪个改变颜色，代码如下：</p>
<pre><code>/**
 * ScrollView的滑动事件监听
 */
@Override
protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);

    /**
     * 计算出当前在两条线里的position
     */
    position = (t + mTextHeight) / (mTextHeight * 2);
    /**
     * 因为此方法会在滑动的时候不停的调用,所以这里设置一个临时的变量来控制
     */
    if (tempPosition != position) {
        int size = mTextGroup.getChildCount();
        for (int i = 0; i &lt; size; i++) {
            TextView tv = (TextView) mTextGroup.getChildAt(i);
            /**
             * 因为我们在数据开头添加了一个空的数据,所以这里position要+1
             */
            if (position + 1 == i) {
                tv.setTextColor(getResources().
                        getColor(android.R.color.holo_blue_dark));
            } else {
                tv.setTextColor(getResources().
                        getColor(android.R.color.darker_gray));
            }
        }
    }
    tempPosition = position;
}
</code></pre><h3 id="滑动结束后把当前数据放在中间（其实我不知道怎么表达了）"><a href="#滑动结束后把当前数据放在中间（其实我不知道怎么表达了）" class="headerlink" title="滑动结束后把当前数据放在中间（其实我不知道怎么表达了）"></a>滑动结束后把当前数据放在中间（其实我不知道怎么表达了）</h3><p>ScrollView没有滑动结束的监听，所以我们只好取巧来弄一个。我们在手指离开屏幕的30ms后来判断当前的scrollY和离开屏幕时候的scrollY是否一样，一样则认定是滑动结束了，如果不一样，我们强行给弄成一样的来结束滑动</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent ev) {
    /**
     * 因为ScrollView没有停止滑动的监听,所以这里取巧
     * 在手指离开屏幕的30ms后判断是否和原来的scrollY一样
     * 如果一样则进入,如果不一样则设置为一样
     */
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        scrollY = getScrollY();
        postDelayed(new Runnable() {
            @Override
            public void run() {
                if (scrollY == getScrollY()) {
                    /**
                     * 获得每次松手后scrollY相对于TextView高度的偏移量
                     */
                    int offset = scrollY % (mTextHeight * 2);

                    /**
                     * 如果偏移量大于TextView高度的一半
                     * 则进入到下一个
                     */
                    if (offset &gt; mTextHeight) {
                        smoothScrollTo(0, scrollY - offset + (mTextHeight * 2));
                    } else {
                        smoothScrollTo(0, scrollY - offset);
                    }
                } else {
                    scrollY = getScrollY();
                    post(this);
                }
            }
        }, 30);
    }
    return super.onTouchEvent(ev);
}
</code></pre><p>到这里就结束了，其实还是蛮简单的，只不过功能甚少，只能实现基本的选择数据，所以我起名为PickerView，当然以后还会对这个项目进行维护，已经上传github，地址<a href="https://github.com/wanglu1209/PickerView" target="_blank" rel="noopener">PickerView</a>，欢迎大家来star或者提bug</p>
<hr>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><p>感谢wangjiegulu的WheelView给的启发，放上地址</p>
<p><a href="https://github.com/wangjiegulu/WheelView" target="_blank" rel="noopener">WheelView</a></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2016/08/20/Android/Android-自定义控件PickerView/" data-id="cjfx9re5g0009j7fy4wgadv3f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/">Python-学装饰器之前，有几个点要理解</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Python/Python-记学习对象可变性/">Python-记学习对象可变性</a>
          </li>
        
          <li>
            <a href="/2017/04/10/Android/Android-ThreadLocal解析/">Android-ThreadLocal解析</a>
          </li>
        
          <li>
            <a href="/2017/02/09/Android/Android-同向滑动冲突/">Android-同向滑动冲突</a>
          </li>
        
          <li>
            <a href="/2017/01/20/Android/Android-MVP Demo/">Android-MVP Demo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 王璐<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>