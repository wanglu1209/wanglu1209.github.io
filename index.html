<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>王璐的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="王璐的博客">
<meta property="og:url" content="http:/index.html">
<meta property="og:site_name" content="王璐的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王璐的博客">
  
    <link rel="alternate" href="/atom.xml" title="王璐的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">王璐的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http:"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Python/Python-学装饰器之前，有几个点要理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/" class="article-date">
  <time datetime="2018-04-13T00:50:44.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/">Python-学装饰器之前，有几个点要理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>要不这样吧，如果编程语言里有个地方你弄不明白，而正好又有个人用了这个功能，那就开枪把他打死，这比学习新特性要容易些，然后过不了多久，那些活下来的程序员就会开始用0.9.6版本的Python，而且他们只需要使用这个版本中易于理解的小部分就好了（眨眼）。                  - Tim Peters</p>
</blockquote>
<p>首先推荐一波和朋友一起弄的壁纸下载，爬取了各大网站的壁纸，总有你喜欢的类型。<a href="http://wp.d2collection.com/" target="_blank" rel="noopener">http://wp.d2collection.com/</a></p>
<p>众所周知，Python里装饰器是一个很重要并且很牛X的功能，他可以在不改变原函数的功能和结构的基础上增加新功能。</p>
<p>但是想要理解装饰器还是有很多知识点的：</p>
<ul>
<li>导入时、运行时</li>
<li>闭包与变量的作用域</li>
<li>nonlocal</li>
</ul>
<p>一般我们的装饰器都是在另外的一个文件里写的，类似xxx_deco。</p>
<p>当我们在别的文件中引入进来并且在自己的函数上定义时，装饰器就<strong>立即运行</strong>了。（当然不是说代码刚写就运行了+_+）</p>
<p>用《流畅的Python》中的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running register(&lt;function f1 at 0x10373d730&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10373d7b8&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x10373d730&gt;, &lt;function f2 at 0x10373d7b8&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure>
<p>从结果我们可以证实刚才的话，在装饰后，就已经运行了。</p>
<p>下面我们来讨论变量的问题，众所周知，一个函数内部的变量在函数执行结束后就被销毁了。那么我们看一个小例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>这是一个利用闭包实现的求平均数的方法，导入运行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> average <span class="keyword">import</span> make_averager</span><br><span class="line">In[<span class="number">3</span>]: avg = make_averager()</span><br><span class="line">In[<span class="number">4</span>]: avg(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">10.0</span></span><br><span class="line">In[<span class="number">5</span>]: avg(<span class="number">11</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">10.5</span></span><br><span class="line">In[<span class="number">6</span>]: avg(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">11.0</span></span><br></pre></td></tr></table></figure>
<p>这里爱思考的盆友会看出来，每次值都被记录了下来，我当时看到这里的时候在想，这不是坑爹么！谁说局部变量执行完就销毁的(╯‵□′)╯︵┻━┻</p>
<p>跑回去看了一下闭包的解释：<strong>：闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</strong></p>
<p>闭包延伸了变量的作用域，还起了个名字叫自由变量。所以上面的series就是一个自由变量。<strong>自由变量是指在本地作用域中绑定的变量</strong>，所以这个series没有被释放掉并且一直可以用。</p>
<p>那么这个时候再来看，如果我想统计有多少个数字呢？代码增加如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>运行如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> average <span class="keyword">import</span> make_averager</span><br><span class="line">In[<span class="number">3</span>]: avg = make_averager()</span><br><span class="line">In[<span class="number">4</span>]: avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/WangLu/.pyenv/versions/3.5.2/lib/python3.5/site-packages/IPython/core/interactiveshell.py"</span>, line <span class="number">2862</span>, <span class="keyword">in</span> run_code</span><br><span class="line">    exec(code_obj, self.user_global_ns, self.user_ns)</span><br><span class="line">  File <span class="string">"&lt;ipython-input-4-2b3d43cb065d&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    avg(<span class="number">10</span>)</span><br><span class="line">  File <span class="string">"/Users/WangLu/Study/FluentPython/average.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> averager</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>报错了，在定义变量之前应用了变量。这跟刚才说的不一致。</p>
<p>在Python中，数字、元组等不可变类型是只读的，想要重新赋值就要重新创建变量，在刚才的例子中，如果重新创建变量的话那就不是自由变量了，没有自由变量的闭包还是闭包么？所以在Python3中引入了<strong>nonlocal</strong>声明，被nonlocal声明的变量为自由变量，闭包中的数据就会更新。</p>
<p>所以，代码改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    series = []</span><br><span class="line">    count = 0</span><br><span class="line"></span><br><span class="line">    def averager(new_value):</span><br><span class="line">        nonlocal count</span><br><span class="line">        count += 1</span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        return total / len(series)</span><br><span class="line"></span><br><span class="line">    return averager</span><br></pre></td></tr></table></figure>
<p>如果是Python2的话，就需要把变量设置为可变的如list等</p>
<p>至此，我们就可以来实现装饰器了，在每次调用的时候输出 哈哈 + 方法名 + 结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha_deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(*args)</span>:</span></span><br><span class="line">        result = func(*args)</span><br><span class="line">        print(<span class="string">'哈哈 -&gt; &#123;&#125;，结果为：&#123;&#125;'</span>.format(func.__name__, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> haha</span><br></pre></td></tr></table></figure>
<p>调用结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> haha_deco <span class="keyword">import</span> haha_deco</span><br><span class="line">In[<span class="number">3</span>]: @haha_deco</span><br><span class="line">  ...: <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(n)</span>:</span></span><br><span class="line">  ...:     <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * demo(n<span class="number">-1</span>)</span><br><span class="line">  ...: </span><br><span class="line">In[<span class="number">4</span>]: demo(<span class="number">5</span>)</span><br><span class="line">哈哈 -&gt; demo，结果为：1</span><br><span class="line">哈哈 -&gt; demo，结果为：2</span><br><span class="line">哈哈 -&gt; demo，结果为：6</span><br><span class="line">哈哈 -&gt; demo，结果为：24</span><br><span class="line">哈哈 -&gt; demo，结果为：120</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">120</span></span><br></pre></td></tr></table></figure>
<p>我觉得想要理解装饰器，这几个点是应该会的。</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><h4 id="爱生活，爱小丽"><a href="#爱生活，爱小丽" class="headerlink" title="爱生活，爱小丽"></a>爱生活，爱小丽</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/" data-id="cjfx8xug0000dqqfym32ox7ws" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python/Python-记学习对象可变性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Python/Python-记学习对象可变性/" class="article-date">
  <time datetime="2018-04-13T00:50:17.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Python/Python-记学习对象可变性/">Python-记学习对象可变性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在刚学Python的时候就知道元组是不可变的，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: id(t)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">4457650000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: t += (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: id(t)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">4456501496</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: t</span><br><span class="line">Out[<span class="number">5</span>]: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>当我们想要改变元组的时候他会新建一个对象来存储值，但是当我们的元组里有一个可变的对象呢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: t1 = ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], )</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: t1[<span class="number">0</span>].append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: t1</span><br><span class="line">Out[<span class="number">10</span>]: ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],)</span><br></pre></td></tr></table></figure>
<p>其实元组保存的只是对象的引用，如果元组里的元素可变那么元素就是可变的。这里说的不可变只是元组保存的引用不变</p>
<p>在说一下深拷贝、浅拷贝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: l1 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: l2 = list(l1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: l2</span><br><span class="line">Out[<span class="number">13</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: l2[<span class="number">1</span>].append(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: l2</span><br><span class="line">Out[<span class="number">15</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: l1</span><br><span class="line">Out[<span class="number">16</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: l1[<span class="number">-1</span>] += (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: l1</span><br><span class="line">Out[<span class="number">19</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: l2</span><br><span class="line">Out[<span class="number">20</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>
<p>list()方法默认做的是浅拷贝。浅拷贝就是只复制最外层的容器，复制出来容器里的元素仍为源容器中元素的引用。即<strong>l2的元素引用还是指向l1的</strong>，所以当l2[1]更改了的时候l1[1]也更改了。但是由于元组是不可变元素，所以当更改他的时候会新创建一个元组对象，所以l1和l2中的互不干扰</p>
<p>而深拷贝则不共享引用，全部重新创建新的引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: l3 = copy.deepcopy(l1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: l3</span><br><span class="line">Out[<span class="number">23</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: l1</span><br><span class="line">Out[<span class="number">24</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: l1[<span class="number">1</span>].append(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: l1</span><br><span class="line">Out[<span class="number">26</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">200</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: l3</span><br><span class="line">Out[<span class="number">28</span>]: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>], (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br></pre></td></tr></table></figure>
<p>接下来说方法形参问题，都知道形参是一个实参的引用。那么这个时候传不可变对象还好。如果传可变参的话，那么方法做的更改就会关系到方法外</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    ...:     a += b</span><br><span class="line">    ...:     <span class="keyword">return</span> a</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: y = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: f(x, y)</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: x</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>所以，尽量不要传递一个可变的对象给函数，除非你想这么做</p>
<p>同理，函数的默认参也不要是一个可变对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: bus1 = HauntedBus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="string">'Alice'</span>, <span class="string">'Bill'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: bus1.pick(<span class="string">'Charlie'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: bus1.drop(<span class="string">'Alice'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">36</span>]: [<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: bus2 = HauntedBus()</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: bus2.passengers</span><br><span class="line">Out[<span class="number">39</span>]: [<span class="string">'Carrie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: bus3 = HauntedBus()</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: bus3.passengers</span><br><span class="line">Out[<span class="number">41</span>]: [<span class="string">'Carrie'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: bus3.pick(<span class="string">'Dave'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: bus3.passengers</span><br><span class="line">Out[<span class="number">43</span>]: [<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: bus2.passengers</span><br><span class="line">Out[<span class="number">44</span>]: [<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: bus2.passengers <span class="keyword">is</span> bus3.passengers</span><br><span class="line">Out[<span class="number">45</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: bus1.passengers</span><br><span class="line">Out[<span class="number">46</span>]: [<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br></pre></td></tr></table></figure>
<p>可以看到bus2和bus3共用了一组乘客，问题就是出在<code>self.passengers = passengers</code>，这里如果我们在创建对象时什么也不传则用了默认参<code>passengers=[]</code>，而默认参是在加载模块的时候定义，不会每次都创建，所以默认参是这个函数的属性，而这个属性是个可变对象的时候，那么修改了之后后续的都会受到影响</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><h4 id="爱生活，爱小丽"><a href="#爱生活，爱小丽" class="headerlink" title="爱生活，爱小丽"></a>爱生活，爱小丽</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Python/Python-记学习对象可变性/" data-id="cjfx8xug2000eqqfy3l7r5c4t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义banner实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-自定义banner实现/" class="article-date">
  <time datetime="2018-04-13T00:48:55.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-自定义banner实现/">Android-自定义banner实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>惯例先上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-f438927e8fb53ae2.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>可以看到这是一个轮播图，只不过我们以前在用的时候一般都是用ViewPager，用正常的ViewPager有几点坏处：</p>
<ul>
<li>不能无限循环</li>
<li>不能控制自动播放</li>
</ul>
<p>所以这就需要自己封装一个了，其实还是用的ViewPager，只不过更改了他的触摸事件并且设置了自动轮播的时间，然后自己写了一个PagerAdapter来实现无限轮播，最后下面的指示器和ViewPager、PagerAdapter封装到了一起，所以使用的时候很简单。<strong>只需要继承自BannerPagerAdapter，重写构造和setView()方法。然后在使用的时候调用方法即可</strong>，基本代码如下：</p>
<pre><code>List&lt;Integer&gt; data = new ArrayList&lt;&gt;();
data.add(R.mipmap.a1);
data.add(R.mipmap.a2);
data.add(R.mipmap.a3);
data.add(R.mipmap.a4);


AdapterDemo ad = new AdapterDemo(this, data);

Banner banner = (Banner) findViewById(R.id.banner);

/**
 * 关于这里的设置参数问题,是需要这样使用的
 * 在设置了小圆点之后才能设置适配器
 * 因为只有在适配器里才会根据一共多少条数据来适配
 * 最后需要调用开始轮播
 * 个人建议在onPause()/onDestroy()方法中来停止 -- stopAutoPlay()
 */
banner.setDot(R.drawable.no_selected_dot, R.drawable.selected_dot).
    setDotGravity(Banner.CENTER).
    setAdapter(ad).
    setOnItemClickListener(new BannerPagerAdapter.onItemClickListener() {
        @Override
        public void onClick(int position) {
            Toast.makeText(MainActivity.this, &quot;&quot; + position, Toast.LENGTH_SHORT).show();
        }
    }).
    startAutoPlay(); 
</code></pre><p>下面是AdapterDemo的代码：</p>
<pre><code>public class AdapterDemo extends BannerPagerAdapter {

    private Context mContext;
    private List&lt;Integer&gt; data;

    public AdapterDemo(Context context, List data) {
        super(context, data);
        mContext = context;
        this.data = data;
    }

    /**
     * 只需要重写构造和这个方法即可
     * 在这里可以设置自己的View,使用自己的图片加载库
     */
    @Override
    public View setView(int position) {
        View v = LayoutInflater.from(mContext).inflate(R.layout.test, null);
        ImageView iv = (ImageView) v.findViewById(R.id.iv);
        iv.setImageResource(data.get(position));
        return v;
    }
}
</code></pre><p>可以看的出来这里给调用者很大的空间来进行自己的操作，在setView中直接可以根据position来设置自己的View和数据，<strong>并且使用自己的图片加载库。</strong></p>
<p>如果感兴趣的可以移步<a href="https://github.com/wanglu1209/Banner" target="_blank" rel="noopener">GitHub</a></p>
<hr>
<p><strong>下面开始说如何写</strong></p>
<p>首先我们要确定一下这个banner有几个需要注意的点：</p>
<ol>
<li>无限轮播</li>
<li>点击事件</li>
<li>指示器</li>
<li>指示器的滑动效果</li>
</ol>
<h3 id="无限轮播、点击事件"><a href="#无限轮播、点击事件" class="headerlink" title="无限轮播、点击事件"></a>无限轮播、点击事件</h3><p>关于无限轮播，我参照的是任玉刚大神的博客，所以我也希望各位去看这个博客，也算是涨点人气，我这里就不写到底如何实现的了，各位可以查看我的代码</p>
<p><a href="http://blog.csdn.net/singwhatiwanna/article/details/46541225" target="_blank" rel="noopener">循环广告位组件的实现 – 任玉刚</a></p>
<h3 id="指示器、滑动效果"><a href="#指示器、滑动效果" class="headerlink" title="指示器、滑动效果"></a>指示器、滑动效果</h3><p>其实我写的时候有好多坑，但是写这篇文章的时候感觉都不是特别难的点（<strong>技术太菜</strong>）</p>
<p>关于指示器，其实现在大部分都是小圆点，这里我实现的思路是创建一个FrameLayout来添加ViewPager和指示器</p>
<p>但是可以看到，这里的指示器会有一个随着页面滑动而滑动的效果，这里就需要两层了，<strong>一个是包含未选中的，一个是包含了选中和未选中的（Group）</strong></p>
<p>代码如下：</p>
<pre><code>private void init() {
    mPager = new BannerViewPager(mContext);
    addView(mPager);
    /**
     * 实例化两个Group
     */
    mFrameLayout = new FrameLayout(mContext);
    mDotGroup = new LinearLayout(mContext);
    /**
     * 设置小圆点Group的方向为水平
     */
    mDotGroup.setOrientation(LinearLayout.HORIZONTAL);
    /**
     * 如果不设置则小圆点在中间
     */
    mDotGroup.setGravity(CENTER | Gravity.BOTTOM);
    /**
     * 两个Group的大小都为match_parent
     */
    LinearLayout.LayoutParams params =
            new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT);
    /**
     * 首先添加小圆点的Group
     */
    mFrameLayout.addView(mDotGroup, params);
    /**
     * 然后添加包含的Group（f**k,表达能力有限）
     */
    addView(mFrameLayout, params);

    /**
     * 添加到任务栈,当前所有任务完事之后添加已经选中的那个小圆点
     */
    post(new Runnable() {
        @Override
        public void run() {
            ImageView iv = new ImageView(mContext);
            iv.setImageDrawable(mContext.getResources().getDrawable(mDot[1]));
            FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            /**
             * 设置选中小圆点的左边距
             */
            params.leftMargin = (int) mDotGroup.getChildAt(0).getX();
            params.gravity = Gravity.BOTTOM;
            mFrameLayout.addView(iv, params);
            mSelectedDot = mFrameLayout.getChildAt(1);
        }
    });
    mPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            /**
             * 获取到当前position
             */
            position %= mAdapter.size;
            /**
             * 判断如果当前的position不是最后一个,那么就设置偏移量来实现被选中小圆点的滑动效果
             */
            if (mSelectedDot != null &amp;&amp; position != mAdapter.size -1) {
                float dx = mDotGroup.getChildAt(1).getX() - mDotGroup.getChildAt(0).getX();
                mSelectedDot.setTranslationX((position * dx) + positionOffset * dx);
            }
        }

        @Override
        public void onPageSelected(int position) {
            position %= mAdapter.size;
            /**
             * 如果已经是最后一个,那么则直接把小圆点定位到那,不然滑动效果会出错
             */
            if (mSelectedDot != null &amp;&amp; position == mAdapter.size - 1) {
                float dx = mDotGroup.getChildAt(1).getX() - mDotGroup.getChildAt(0).getX();
                mSelectedDot.setTranslationX(position * dx);
            }
        }

        @Override
        public void onPageScrollStateChanged(int state) {

        }
    });

}
</code></pre><p>可以看到我们首先添加了ViewPager，然后我们添加了未选中指示器的Group，之后我们才添加的选中的指示器。在添加选中指示器的时候用了一个post，这个方法是把runnable里的代码添加到任务栈，前面的任务结束了这个任务才会执行，所以我们可以获取到第一个未选中小圆点的坐标，然后把选中指示器覆盖上去，后来我们移动的时候就直接移动选中的指示器就好了。</p>
<p>关于滑动指示器，其实就是用了一个setTranslationX()方法，这个方法可以虽然移动View的位置，但是没有真正的移动该View，所以我们在移动的时候根据position来计算，但是当移动到最后一个的时候就不应该用这个方法了，如果还用的话就会造成一种『出界』了的感觉，所以这里在最后一个的时候不进入方法。</p>
<p>有人应该会想到『在第一页的时候』，这里我们大家可以自己测试一下，当手指向右滑的时候，就已经是size-1页了，所以我们直接就用一个判断就够了</p>
<p><strong>额，写的乱七八糟，但是代码会说话的~</strong></p>
<p><strong>还是那句话，感兴趣的请移步GitHub哟~</strong></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-自定义banner实现/" data-id="cjfx8xufy000cqqfy9rpcnsr2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义View" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-自定义View/" class="article-date">
  <time datetime="2018-04-13T00:40:13.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-自定义View/">Android - 自定义View</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Android-自定义View"><a href="#Android-自定义View" class="headerlink" title="Android - 自定义View"></a>Android - 自定义View</h3><hr>
<p>在自定义View的时候一般我们会重写onDraw(Canvas canvas)方法，然后在系统给定的canvas画布上绘画就可以了。如果需要使用wrap_content属性，那么还需要重写onMeasure()方法</p>
<blockquote>
<p>对现有的控件来进行扩展</p>
</blockquote>
<p>这里以TextView为例，要实现这样的一个效果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-f3394b37f9c32fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>只是在原有的TextView上加了一层框，其实就是绘制一个空心的矩形，理解这个我们就可以着手写代码了</p>
<pre><code>protected void onDraw(Canvas canvas) {
    /**
     * 在调用super之前，这里也就是在绘制文本内容前来处理自己的逻辑
     */
    Paint p = new Paint();    
    p.setStyle(Paint.Style.STROKE);    //设置为空心
    p.setStrokeWidth(5);                //设置外框线的宽度
    p.setColor(Color.YELLOW);            //设置线的颜色
    /**
     * 绘制矩形，起始x坐标，起始y坐标，终点x坐标，终点y坐标，用来绘画的paint
     */
    canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), p);

    super.onDraw(canvas);

    /**
     * 在绘制完文本后处理自己的逻辑
     */
}
</code></pre><p>这时候就完成了对现有的控件的扩展，我们在XML中使用我们自定义的控件</p>
<pre><code>&lt;com.github.wanglu1209.MyTextViewDemo
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_margin=&quot;20dp&quot;
    android:text=&quot;My Android TextView&quot; /&gt;
</code></pre><p>这里和使用正常的TextView没有什么区别，现在运行一下程序就是我们上面看到的效果了</p>
<hr>
<blockquote>
<p>定义全新的控件</p>
</blockquote>
<p>有的时候系统给定的控件不能满足我们的需求，那么这个时候就需要重新自定义一个控件。这里我们就需要重写onMeasure()和onDraw()方法等方法来实现逻辑了，通过重写onTouchEvent()来实现触控的事件</p>
<p>来写一个实例，大约就长这个样子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-7cc5ae38e23d1af6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>首先来分析一下，无非就是两个部分，中间的圆和外面的弧线，只要在onDraw()中依次绘制就可以了。</p>
<p>在构造中初始化参数</p>
<pre><code>private void initView() {
    mCirclePaint = new Paint();
    mCirclePaint.setColor(getResources().getColor(android.R.color.holo_blue_bright));
    mCirclePaint.setAntiAlias(true);    //设置抗锯齿

    mArcPaint = new Paint();
    mArcPaint.setAntiAlias(true);
    mArcPaint.setStyle(Paint.Style.STROKE);     //设置为空心
    mArcPaint.setStrokeWidth(40);
    mArcPaint.setColor(getResources().getColor(android.R.color.holo_blue_bright));

}
</code></pre><p>然后在onMeasure()中获取宽度，这里为了简单，直接就是屏幕的宽度</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int length = MeasureSpec.getSize(widthMeasureSpec);
    mCircleXY = length / 2;
    mRadius = mCircleXY / 2;
    mRectF = new RectF(
            (float) (length * 0.1),
            (float) (length * 0.1),
            (float) (length * 0.9),
            (float) (length * 0.9)
    );
}
</code></pre><p>最后在onDraw()中绘制这两个图形即可</p>
<pre><code>protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    /**
     * 绘制圆形,参数依次为 圆的中心x坐标,圆的中心y坐标,圆的半径,画圆的笔
     */
    canvas.drawCircle(mCircleXY, mCircleXY, mRadius, mCirclePaint);
    /**
     * 绘制扇形,参数依次为 扇形的大小,起始角度,角度,是否与半径连线,画笔
     */
    canvas.drawArc(mRectF, 270, 240, false, mArcPaint);
}
</code></pre><p>现在运行程序，就可以看到我们最开始的效果啦</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-自定义View/" data-id="cjfx8xufs0009qqfy09va5vz0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-各种情况下的『自动加载更多』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-各种情况下的『自动加载更多』/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-各种情况下的『自动加载更多』/">Android-各种情况下的『自动加载更多』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在写项目的时候总是会碰到上拉自动加载更多这个需求，但是又不想用PullToRefresh，其实我们可以直接判断出来是否已经滑动到底端，如果滑动到底端则加载。一般的需求有在ScrollView、RecyclerView、ListView中自动加载</p>
<h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><p>在RecyclerView中判断是否滑动到底部，其实就是判断是否已经达到了<strong>最后一个可见的item &amp;&amp; 滑动结束</strong>，伪代码如下</p>
<pre><code>RecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
    @Override
    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
        if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; 
            (layoutManager.findLastVisibleItemPosition() == 
            layoutManager.getItemCount() - 1)
            &amp;&amp; !isRefreshing) {
            isRefreshing = true;         
            //处理逻辑
        }
    }
});
</code></pre><p>解释一下上面的判断，当状态为SCROLL_STATE_IDLE(停止滑动)时，并且目前可见的最后一个item的位置为总数-1，并且当前不在刷新状态中（<strong>因为有的时候需要网络请求，所以可能滑动到底部后一直请求接口，定义一个变量来判断一下</strong>），然后就可以处理逻辑了</p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>关于ListView的滑动底部监听其实和RecyclerView的判断差不多，代码如下：</p>
<pre><code>ListView.setOnScrollListener(new OnScrollListener() {
            @Override
            public void onScrollStateChanged(AbsListView view, int scrollState) {

                    if((scrollState == OnScrollListener.SCROLL_STATE_IDLE) &amp;&amp;
                            view.getLastVisiblePosition() == (view.getCount() - 1)
                            &amp;&amp; !isRefreshing) {
                        //处理逻辑
                    }
                }
            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem,
                                 int visibleItemCount, int totalItemCount) {
            }
        });   
</code></pre><p>ListView和RecyclerView差不多，就不多做解释了    </p>
<h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><p>最后关于ScrollView滑动到底部，因为<strong>ScrollView没有停止滑动的监听，所以使用要慎重！</strong></p>
<p>如果想要使用ScrollView来监听，那就要重写ScrollView，代码如下：</p>
<pre><code>onScrollBottomListener bottomListener;

public void setOnScrollBottomListener(onScrollBottomListener bottomListener){
    this.bottomListener = bottomListener;
}

public interface onScrollBottomListener{
    void onBottom();
}

@Override
protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    super.onScrollChanged(l, t, oldl, oldt);
    if(getHeight() + getScrollY() &gt;= getChildAt(0).getMeasureHeight()){
        if(bottomListener != null){
            bottomListener.onBottom();
        }
    }
}    
</code></pre><p>看的出来，我们定义了一个接口来回调，因为ScrollView里只能包含一个布局，所以可以根据这个特性来判断，所以在滑动事件监听里获取到当前ScrollView的高度和Y轴的滑动值的相加来和ScrollView包含的布局的高度来进行对比，如果大于的话那么就等于滑动到底部（<strong>但是这个方法会调用好多次</strong>）    </p>
<hr>
<p>以前工作的时候碰到过这些需求，当时在网上找也没有找到合适的（<strong>确实当时技术很菜</strong>），过了好久了，分享出来，希望后来又有需求的少碰坑- -</p>
<p>当然可以在布局的后面加一个FooterView，加载数据的时候显示『正在加载…』，加载到没有数据的时候显示一个『- end -』之类的</p>
<p>没写Demo，有兴趣的可以自己试试啦~</p>
<p>洗洗睡了，凌晨1:05</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-各种情况下的『自动加载更多』/" data-id="cjfx8xufh0004qqfy0t8pm2j9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-View的测量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-View的测量/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-View的测量/">Android View的测量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Android View的测量</p>
</blockquote>
<p>在绘制View之前，要对整个View进行测量，这个过程就在onMeasure()方法中进行的。</p>
<h4 id="测量的模式"><a href="#测量的模式" class="headerlink" title="测量的模式"></a>测量的模式</h4><ol>
<li>EXACTLY<ul>
<li>精确值模式，当控件的width和height设置为具体值或者match_parent时就是这个模式</li>
</ul>
</li>
<li>UNSPECIFIED<ul>
<li>这个属性不指定测量的模式，View想多大就多大</li>
</ul>
</li>
<li>AT_MOST<ul>
<li>最大值模式，当控件的width和height设置为wrap_context时就是这个模式，控件的大小随着子控件的大小而变化</li>
</ul>
</li>
</ol>
<p>其中View类<strong>默认的</strong>onMeasure()方法<strong>只支持EXACTLY模式</strong>，所以说如果不重写onMeasure()方法的话就只能使用EXACTLY模式。</p>
<p>一言不合上代码</p>
<pre><code>public CustomView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    setBackgroundColor(Color.BLUE);
} 
</code></pre><p>这里我只给当前自定义View设置了一个背景颜色，然后在XML中设置成wrap_content</p>
<pre><code>&lt;com.github.wanglu1209.CustomView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt; 
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1822424-15549d4c06f7dfbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>运行起来就是这样全屏的，下面我们还是这个例子，重写onMeasure()方法</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);

    int specMode, specSize = 0;
    int mWidth, mHeight;

    /**
     * Measure Width
     */
    specMode = MeasureSpec.getMode(widthMeasureSpec);
    switch (specMode){
        case MeasureSpec.AT_MOST:   //wrap_content
            specSize = 200;
            break;
        case MeasureSpec.EXACTLY:   //math_content 和 精确值
            specSize = MeasureSpec.getSize(widthMeasureSpec);
            break;
        case MeasureSpec.UNSPECIFIED:
            specSize = 400;
            break;
    }
    mWidth = specSize;

    /**
     * Measure Height
     */
    specMode = MeasureSpec.getMode(heightMeasureSpec);
    switch (specMode){
        case MeasureSpec.AT_MOST:   //wrap_content
            specSize = 200;
            break;
        case MeasureSpec.EXACTLY:   //math_content 和 精确值
            specSize = MeasureSpec.getSize(heightMeasureSpec);
            break;
        case MeasureSpec.UNSPECIFIED:
            specSize = 400;
            break;
    }
    mHeight = specSize;

    /**
     * 最后调用setMeasuredDimension进行赋值
     */
    setMeasuredDimension(mWidth, mHeight);
}
</code></pre><p>可以看到这里我们给wrap_content赋值200，我们XML代码不变还是wrap_content，运行一下程序</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-0e9fc7b558921b74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看的出来大小确实变成了200，通过这个小例子就可以对View的测量有一个不错的认识了，并没有什么高深莫测的东西，一步一步来。</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-View的测量/" data-id="cjfx8xufm0005qqfy4902346c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-属性动画" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-属性动画/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-属性动画/">Android-属性动画</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Android3.0以前的动画框架Animation存在着局限性：只能改变显示的位置，但是不能真正的更改View的位置，所以在Android3.0以后Google就推出了<strong>属性动画（Animator）</strong></p>
<p>在Animator框架动画中使用最多的就是ObjectAnimator和AnimatorSet。使用ObjectAnimator来进行控制，一个ObjectAnimator只能控制一个对象的一个值，而使用多个ObjectAnimator组合到一个AnimatorSet当中形成一个动画的集合。其中<strong>最重要的是属性动画通过调用属性的get/set方法来真实的控制一个View的属性</strong>，所以基本的的动画都可以用属性动画来实现</p>
<h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><p>创建一个ObjectAnimor只需要调用ObjectAnimator的静态工厂方法就可以直接返回一个ObjectAnimator对象，其属性有需要控制的对象，和对象的属性名（动画的名称），但是这个属性必须要有get、set方法，因为在内部会调用Java的反射机制来调用set函数修改属性值</p>
<h4 id="看一个小实例"><a href="#看一个小实例" class="headerlink" title="看一个小实例"></a>看一个小实例</h4><p>把一个Button向右方平移300，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-9118622cec9694b9.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>代码如下：</p>
<pre><code>btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        /**
         * 创建ObjectAnimator对象
         * 设置对象和对象属性还有值
         */
        ObjectAnimator oa = ObjectAnimator.ofFloat(btn, &quot;translationX&quot;, 300);
        oa.setDuration(300);    //设置时间为300ms
        oa.start();
    }
});
</code></pre><p>这里我们首先通过ObjectAnimator的静态工厂方法创建了一个对象，这里的三个参数：第一个参数则是需要曹工的对象，第二个是要操纵的属性，第三个是一个可变数组，这里我们只给了一个参数300，最后调用start()方法就可以看到动画啦。</p>
<h2 id="常用的可以直接使用的属性动画的值"><a href="#常用的可以直接使用的属性动画的值" class="headerlink" title="常用的可以直接使用的属性动画的值"></a>常用的可以直接使用的属性动画的值</h2><ul>
<li>translationX/translationY    ：作为一种增量来控制对象从它的父布局的左上角偏移的位置</li>
<li>rotation、rotationX、rotationY：控制对象围绕支点来进行2D和3D旋转</li>
<li>pivotX、pivotY：这两个属性控制着对象的支点位置，围绕着这个支点进行旋转和缩放，在默认情况下支点就是该对象的中心点</li>
<li>x、y：这两个属性描述了对象在他容器中的最终位置，他是最初的左上角坐标和translationX、translationY值的累积和</li>
<li>alpha：透明度，默认值是1（不透明），0代表完全透明</li>
</ul>
<p>可以看的出来大部分的动画都包含了，但是如果说有的属性没有get/set方法，那是不是就不能更改了呢？我们可以写一个自定义的属性类或者包装类来间接的给这个属性添加get/set方法。</p>
<p>来看一下包装类，代码如下：</p>
<pre><code>public class WrapperView {
    private View mTarget;

    public WrapperView(View mTarget) {
        this.mTarget = mTarget;
    }

    public int getWidth(){
        return mTarget.getLayoutParams().width;
    }

    public void setWidth(int width){
        mTarget.getLayoutParams().width = width;
        mTarget.requestLayout();
    }
}
</code></pre><p>通过以上的代码就给一个width属性进行了包装，等到使用的时候只需要通过包装类就可以间接的调用到get/set方法了，如下：</p>
<pre><code>btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        /**
         * 创建ObjectAnimator对象
         * 设置对象和对象属性还有值
         */
        ObjectAnimator oa = ObjectAnimator.ofInt(new WrapperView(btn), &quot;width&quot;, 500);
        oa.setDuration(300);
        oa.start();
    }
});
</code></pre><p>还是熟悉的配方，还是原来的味道！这里只不过我们换了一下创建ObjectAnimator对象的方法，因为我们的setWidth方法里的参数是int类型的，所以我们的静态工厂方法需要使用ofInt()方法，如果还是使用ofFloat()的话会提示<code>W/PropertyValuesHolder: Method setWidth() with type float not found on target class class com.androidqunyingzhuan.WrapperView</code>。没有找到类型为float的set方法，运行一下程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-38e42ab877d3ddfc.gif?imageMogr2/auto-orient/strip" alt=""></p>
<hr>
<h2 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h2><p>这个属性类似于AnimationSet，在属性动画中，如果针对同一个对象的多个属性并且同时作用多种动画就可以使用PropertyValuesHolder实现。比如在平移的过程中同时改变X、Y轴的缩放，代码如下：</p>
<pre><code>PropertyValuesHolder p1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 300);
PropertyValuesHolder p2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1, 0, 1);
PropertyValuesHolder p3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1, 0, 1);
ObjectAnimator.ofPropertyValuesHolder(btn, p1, p2, p3).setDuration(1000).start();
</code></pre><p>这样我们就把这三个动画同时作用在一个对象上了，运行程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-dcda53da332406d2.gif?imageMogr2/auto-orient/strip" alt=""></p>
<hr>
<h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><p>ValueAnimator在属性动画中是非常重要的，它是属性动画的核心所在，ObjectAnimator也是继承的ValueAnimator</p>
<p>ValueAnimator不提供任何动画的实现，他像是一个数值发生器，用来产生具有一定规律的数字，来让调用者控制动画的实现过程，通常情况下在ValueAnimator的AnimatorUpdateListener中监听数值的变化，来完成动画的变换</p>
<pre><code>ValueAnimator va = ValueAnimator.ofFloat(0, 100);
va.setDuration(2000).start();
va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator valueAnimator) {
        btn.setText(valueAnimator.getAnimatedValue() + &quot;&quot;);
    }
});
</code></pre><p>我们通过ofFloat()方法来创建了一个ValueAnimator对象，设置值的变换是从0f到100f，设置时间为2秒，然后我们在AnimatorUpdateListener中获取当前值让btn来显示，效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-5b58a04d86733d96.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h4 id="动画事件的监听"><a href="#动画事件的监听" class="headerlink" title="动画事件的监听"></a>动画事件的监听</h4><p>Android提供给我们了一个接口，可以很方便的监听到一个动画的所有过程：</p>
<pre><code>mAnimator.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animator) {

    }

    @Override
    public void onAnimationEnd(Animator animator) {

    }

    @Override
    public void onAnimationCancel(Animator animator) {

    }

    @Override
    public void onAnimationRepeat(Animator animator) {

    }
});
</code></pre><p>但是大部分的时候我们只会关心动画完成之后我们需要做些什么，所以Android还提供了一个适配器来让我们选择</p>
<pre><code>oa.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        super.onAnimationEnd(animation);
    }
});
</code></pre><hr>
<h2 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h2><p>对于在一个对象同一时间作用多个属性动画效果前面已经用PropertyValuesHolder实现了这样的效果，但是AnimatorSet不仅能实现这样的效果，同时能实现更为精确的顺序控制，下面我们用AnimatorSet来实现上面PropertyValuesHolder演示的动画。代码如下：</p>
<pre><code>ObjectAnimator a1 = ObjectAnimator.ofFloat(btn, &quot;translationX&quot;, 300);
ObjectAnimator a2 = ObjectAnimator.ofFloat(btn, &quot;scaleX&quot;, 1, 0, 1);
ObjectAnimator a3 = ObjectAnimator.ofFloat(btn, &quot;scaleY&quot;, 1, 0, 1);
AnimatorSet set = new AnimatorSet();
set.setDuration(1000);
set.playTogether(a1, a2, a3);
set.start();
</code></pre><p>这里我们只是想要和用PropertyValuesHolder演示的动画一样，所以我们使用了playTogether()方法来进行控制动画同时进行，当然还可以使用别的方法，例如playSequentially()，with()，before()，after()等方法来控制多个动画的工作方式，从而做到对动画播放顺序的精确控制，这里的动画和上面的一样，就不放图片了</p>
<hr>
<h2 id="animate方法"><a href="#animate方法" class="headerlink" title="animate方法"></a>animate方法</h2><p>Google在Android3.0以后，给View添加了一个animate方法来直接驱动属性动画，这可以认为是属性动画的简写形式，代码如下：</p>
<pre><code>btn.animate()
        .translationX(300)
        .y(300)
        .setDuration(1000)
        .withStartAction(new Runnable() {
            @Override
            public void run() {

            }
        }).withEndAction(new Runnable() {
            @Override
            public void run() {

            }
        }
).start();
</code></pre><p>设置了两个动画，这里是同时进行的，还有两个回调方法，开始和结束</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-5f721d3886a0442e.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p><strong>这样一来，简单的属性动画效果就都说完啦</strong></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-属性动画/" data-id="cjfx8xufo0006qqfys3wgbn7i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-Android性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-Android性能优化/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-Android性能优化/">Android-Android性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>其实关于性能优化这个我也只是学到个皮毛，我是按照书上说的加上自己理解的来写，<strong>如果有不对的地方，请指正，我也是个菜鸟。谢谢</strong></p>
</blockquote>
<p>Android性能的优化主要分为两点</p>
<ol>
<li>布局优化</li>
<li>内存优化</li>
</ol>
<h2 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h2><p>首先来看一下布局优化，系统在渲染UI的时候会消耗大量的资源，所以，对布局的优化就显得尤为重要</p>
<h4 id="避免Overdraw"><a href="#避免Overdraw" class="headerlink" title="避免Overdraw"></a>避免Overdraw</h4><p>也就是避免过度的绘制，过度的绘制会浪费更多的资源，<strong>举个例子，Android系统会默认绘制Activity的背景，这时候我们再设置一个背景，这样默认的背景就属于过度绘制了，</strong>在『开发者工具』中有一个『调试GPU过度绘制』的选项，我们打开就可以通过颜色来判断过度绘制的次数，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-0cf8e3b06aa8b4ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>所以说我们尽可能的<strong>增大蓝色区域，减少红色区域</strong></p>
<h4 id="优化布局层级"><a href="#优化布局层级" class="headerlink" title="优化布局层级"></a>优化布局层级</h4><p>在Android系统中，系统对View进行测量、布局、绘制的时候，都是通过对View树的遍历来进行的，所以说<strong>一个布局的层级太多，就会严重影响测量、布局、绘制的速度，所以要降低View树的高度，Google在文档中建议布局的层级不超过10层，所以还要避免嵌套没有用的布局</strong></p>
<h4 id="使用include标签"><a href="#使用include标签" class="headerlink" title="使用include标签"></a>使用include标签</h4><p>相信大家都会在项目的时候遇到toolbar，或者一个UI在多个界面使用的问题，遇到这种问题的时候我们一般都会用include（毕竟郭神『第一行代码』教的好），这样就减少了代码冗余，而且还利于后期更改</p>
<h4 id="使用ViewStub实现View的延时加载"><a href="#使用ViewStub实现View的延时加载" class="headerlink" title="使用ViewStub实现View的延时加载"></a>使用ViewStub实现View的延时加载</h4><p>ViewStub标签和View.GONE的方式差不多，但是ViewStub只会在显示的时候去渲染，而GONE在初始化的时候就已经渲染完毕了，所以相比来说ViewStub的效率更高。下面来通过代码使用一下ViewStub</p>
<p>首先我们定义一个布局文件</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/tv&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>这里面只放了一个TextView，然后我们在自己的布局中通过ViewStub来引用他</p>
<pre><code>&lt;Button
   android:id=&quot;@+id/btn&quot;
   android:layout_width=&quot;wrap_content&quot;
   android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;ViewStub
   android:id=&quot;@+id/vs&quot;
   android:layout_width=&quot;wrap_content&quot;
   android:layout_height=&quot;wrap_content&quot;
   android:layout=&quot;@layout/view_stub&quot;/&gt;
</code></pre><p>这里的逻辑是点击按钮然后出现ViewStub引用的布局（也就是我们上面写的那个布局文件）</p>
<pre><code>findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        ViewStub vs = (ViewStub) findViewById(R.id.vs);
        View vsView = vs.inflate();
        TextView tv = (TextView) vsView.findViewById(R.id.tv);
        tv.setText(&quot;hahaha&quot;);

    }
});
</code></pre><p>这里想要把ViewStub引用的布局显示出来有两种办法，一种是ViewStub.setVisibility();另一种就是ViewStub.inflate();这两种方法的区别就是inflate()能返回引用的布局，然后可以通过这个布局来找到里面的子View来进行操作</p>
<p>运行程序点击按钮，就可以看到TextView已经显示出来了，并且已经赋值『hahaha』</p>
<h4 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h4><p>这个工具可以显示我们的布局，但是只可以在模拟器和工厂的Demo机上用，不过Google的大神提供了一个开源的项目ViewServer，有兴趣的可以看一下，地址：<a href="https://github.com/romainguy/ViewServer" target="_blank" rel="noopener">ViewServer</a></p>
<p>这个就不过多阐述了，有兴趣的可以自行查看一下相关的资料</p>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>我们都知道，最近Android的厂商就是在拼配置，其中我们最关注的就是内存几个G，但是Android手机有的内存很大，但是很卡，这是因为有的手机软件在手机内存低的情况下不能被杀死，也就是我们说的『防杀』</p>
<p>我们知道内存一般分为这几个部分</p>
<ul>
<li>寄存器</li>
<li>栈</li>
<li>堆</li>
<li>静态存储区</li>
<li>常量池</li>
</ul>
<p>其中寄存器运算速度最快，但是我们在程序里无法控制</p>
<p>栈里存放基本数据类型</p>
<p>堆里存放对象和数组，在堆中的一般由Java的GC还管理</p>
<p>静态存储区在固定的位置存放应用程序中运行时一直存在的数据，Java专门划分了一个区域来管理静态变量</p>
<p>常量池就是该类型所使用到的常量的集合</p>
<h4 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h4><p>我们都知道在Android中是造成OOM的最大威胁，因为它占用的内存特别多，所以我们应该：</p>
<ul>
<li>使用适当分辨率大小的图片<ul>
<li>由于Android在做适配的时候会对不同分辨率的文件夹下的图片来进行缩放适配，如果图片的分辨率与资源分辨率不匹配的话就会导致消耗更多的资源</li>
</ul>
</li>
<li>使用缓存<ul>
<li>一般有内存缓存和硬盘缓存</li>
</ul>
</li>
</ul>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul>
<li>对常量使用static</li>
<li>使用静态方法，静态方法比普通方法提高15%左右的访问速度</li>
<li>减少没有必要的成员变量，如果能定义成局部变量就最好定义成局部变量</li>
<li>减少不必要的对象</li>
<li>少用枚举、迭代器</li>
<li>对Cursor、Receiver、File等对象，要注意回收和取消注册</li>
<li>使用SurfaceView来代替View进行大量并且频繁的绘图操作</li>
<li>尽量使用视图缓存，不是每次都执行inflate()来解析视图</li>
<li>避免使用反射</li>
<li>使用RenderScript、OpenGL来进行非常复杂的绘图操作</li>
</ul>
<p>以上就是对Android性能优化的一些点，如果你用AndroidStudio的话，AndroidStudio提供了一个内存监视的工具，还是很好用的，如果你没用AndroidStudio，那么我建议你使用AndroidStudio~</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-Android性能优化/" data-id="cjfx8xuf70001qqfyivmn4r58" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-自定义ViewGroup" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-自定义ViewGroup/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-自定义ViewGroup/">自定义ViewGroup</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><blockquote>
<p>自定义ViewGroup需要注意什么</p>
</blockquote>
<p>首先我们要明确一点，ViewGroup就是用来存放View的容器，用来对子View进行管理，给子View添加规则，so</p>
<ol>
<li>对子View进行测量，重写onMeasure()方法</li>
<li>对子View的布局进行控制，重写onLayout()方法</li>
<li>重写onTouchEvent()，dispatchEvent()来对点击触控事件进行控制</li>
</ol>
<hr>
<blockquote>
<p>实例</p>
</blockquote>
<p><strong>长这个样子</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-d70282c81ab583c5.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>从这个图就可以看的出来我们的需求</p>
<ol>
<li>可以滑动</li>
<li>当滑动大于一定距离的时候显示下一个子View</li>
<li>如果小于一定距离那么就回到原位</li>
</ol>
<p>首先这里可以看的出来，我们每一个子View都是沾满一个屏幕的，所以这里整个ViewGroup的高度就能确定出来了，就是屏幕的高度乘子View的个数</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int count = getChildCount();
    for (int i = 0; i &lt; count; i++) {
        View child = getChildAt(i);         //获得每一个子view
        measureChild(child, widthMeasureSpec, heightMeasureSpec);      //测量子view
    }
}
</code></pre><p>我们先在onMeasure()方法中测量每一个子View，这里直接调用measureChild()方法就可以进行对子View的测量，用一个for循环很方便。</p>
<pre><code>protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int childCount = getChildCount();
    MarginLayoutParams mlp = (MarginLayoutParams) getLayoutParams();
    /**
     * 这里对整个ViewGroup的高度进行初始化
     * 屏幕的高度乘子View的个数
     */
    mlp.height = mScreenHeight * childCount; 
    setLayoutParams(mlp);


    for (int i = 0; i &lt; childCount; i++) {
        View child = getChildAt(i);
        if (child.getVisibility() != View.GONE) {
            /**
             * 这里对子View进行布局,由于我们的ViewGroup是上下滑动
             * 所以只需要确定top和bottom两个值就可以,让他们从上到下排列
             */
            child.layout(
                    l,
                    i * mScreenHeight,
                    r,
                    (i + 1) * mScreenHeight
            );
        }
    }
}
</code></pre><p>到这里我们就已经完成了对ViewGroup的测量和对子View位置的控制，接下来就是对触摸事件进行控制</p>
<pre><code>public boolean onTouchEvent(MotionEvent event) {
    int y = (int) event.getY();

    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mLastY = y;
            mStartY = getScrollY();
            break;
        case MotionEvent.ACTION_MOVE:
            if (!mScroller.isFinished()) {
                mScroller.abortAnimation();
            }
            int dy = mLastY - y;

            /**
             * getScrollY()小于0则为第一屏
             */
            if (getScrollY() &lt; 0) {
                dy = 0;
            }
            /**
             * 最后一屏
             */
            if (getScrollY() &gt; mTotalHeight - mScreenHeight) {
                dy = 0;
            }
            scrollBy(0, dy);
            mLastY = y;
            break;
        case MotionEvent.ACTION_UP:
            int dScrollY = check();

            if (dScrollY &gt; 0) { //从下往上滑
                /**
                 * 如果这个距离小于屏幕的1/3
                 * 那么就回到原位,也就是当前距离取负值
                 * 如果大于屏幕的1/3
                 * 那么就直接进入到下一个子View
                 */
                if (dScrollY &lt; mScreenHeight / 3) {
                    mScroller.startScroll(
                            0, getScrollY(),
                            0, -dScrollY)
                    ;
                } else {
                    mScroller.startScroll(
                            0, getScrollY(),
                            0, mScreenHeight - dScrollY
                    );
                }
            } else {
                if (-dScrollY &lt; mScreenHeight / 3) {
                    mScroller.startScroll(
                            0, getScrollY(),
                            0, -dScrollY
                    );
                } else {
                    mScroller.startScroll(
                            0, getScrollY(),
                            0, -mScreenHeight - dScrollY
                    );
                }
            }
            break;

    }
    postInvalidate();   //重绘
    return true;
}

private int check() {
    int mEnd = getScrollY();
    /**
     * 判断滑动方向
     * true 从下往上滑
     * false 从上往下滑
     */
    boolean isUp = mEnd - mStartY &gt; 0;
    /**
     * 关于这两个变量,读者可以自行的打印出来理解一下
     * 用语言来描述不好描述（好吧,其实是表达能力有限）
     */
    int lastPrev = mEnd % mScreenHeight;
    int lastNext = mScreenHeight - lastPrev;
    if (isUp) {
        return lastPrev;
    } else {
        return -lastNext;
    }
}

@Override
public void computeScroll() {
    super.computeScroll();
    if(mScroller.computeScrollOffset()){
        scrollTo(0, mScroller.getCurrY());
        postInvalidate();
    }
}
</code></pre><ol>
<li>这里我们首先在ActionDown事件中获取到第一次碰到屏幕时候的Y轴偏移量</li>
<li>然后我们在ActionMove事件中来对这个值来进行运算并且调用scrollBy()方法来进行滑动</li>
<li>最后我们在ActionUp方法中对这个事件进行总的处理，首先我们在check()方法中判断用户是从上往下滑还是从下往上滑，然后通过滑动方向来计算值并且返回，接着我们用check()方法返回的数据来进行判断滑动的距离是否大于屏幕的三分之一，如果大于，则调用Scroller.startScroll()方法来进行滑动到下/上一屏，如果小于则返回原位。</li>
</ol>
<p>至此自定义ViewGroup就完全结束了，运行一下程序，可以看到我们开始的效果已经呈现出来了。</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-自定义ViewGroup/" data-id="cjfx8xufq0008qqfysye6cpl9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android-Paint高级-PorterDuffXfermode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Android/Android-Paint高级-PorterDuffXfermode/" class="article-date">
  <time datetime="2018-04-13T00:39:31.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Android/Android-Paint高级-PorterDuffXfermode/">Android-Paint高级-PorterDuffXfermode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实在前面的文章中也都用到了画笔（Paint），了解了一些常用的属性，比如抗锯齿，带边框，空心，宽度等，这些都是最基本的属性，下面来说一个高级属性『PorterDuffXfermode』</p>
<h2 id="PorterDuffXfermode"><a href="#PorterDuffXfermode" class="headerlink" title="PorterDuffXfermode"></a>PorterDuffXfermode</h2><p>首先看一张图</p>
<p><img src="http://pic4.zhongsou.com/img?id=522984b61da05c120fd" alt=""></p>
<p>PoerterDuffXfermode设置的是两个图层交集区域的显示方式，其中dst是先画的图形，src是后画的图形。</p>
<p>这里列举了16种，当然有的都不怎么经常使用，最常用的就是DST_IN、SRC_IN来将矩形图片变成圆角图片或者圆形图片了。下面就来进行一个实例CircleImageView（好久之前就看过鸿神的这个View，一直不怎么理解，书看到这一章节就忽然想起来了，自己重新写一遍），完成图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-7c5ffb9fe73e0d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="分如下几步"><a href="#分如下几步" class="headerlink" title="分如下几步"></a>分如下几步</h4><ol>
<li>获得图片</li>
<li>测量宽高</li>
<li>创建画布</li>
<li>画一个圆</li>
<li>使用PerterDuffXfermode来控制下一个图片和刚才的圆交集</li>
<li>画图片</li>
<li>完事</li>
</ol>
<p>首先我们在构造函数中获得图片：</p>
<pre><code>public CircleImageView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleImageView, defStyleAttr, 0);
    try {
        mBitmap = BitmapFactory.decodeResource(getResources(), a.getResourceId(R.styleable.CircleImageView_src, -1));
        if (mBitmap == null) {
            throw new RuntimeException(&quot;src Null!&quot;);
        }
    } finally {
        a.recycle();
    }
}
</code></pre><p>然后我们在onMeasure()中控制图片的宽高</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    mWidth = measureWidthAndHeight(MeasureSpec.getSize(widthMeasureSpec));
    mHeight = measureWidthAndHeight(MeasureSpec.getSize(heightMeasureSpec));
    setMeasuredDimension(mWidth, mHeight);
}

private int measureWidthAndHeight(int size) {
    int mode = MeasureSpec.getMode(size);
    switch (mode) {
        case MeasureSpec.UNSPECIFIED:
        case MeasureSpec.AT_MOST:
            return 200;
        case MeasureSpec.EXACTLY:
        default:
            return size;
    }
}
</code></pre><p>这里我们给wrap_content设置了一个200的值，然后我们在onDraw()方法中完成我们剩下的工作：</p>
<pre><code>protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.drawBitmap(createBitmap(), 0, 0, null);
}

private Bitmap createBitmap() {
    /**
     * 获取宽高最小值,重新生成一个Bitmap
     */
    int min = Math.min(mHeight, mWidth);
    mBitmap = Bitmap.createScaledBitmap(mBitmap, min, min, false);

    /**
     * 根据原有的Bitmap再生成一个Bitmap,当做Canvas的参数
     * 如果在Canvas的构造中带入一个Bitmap的话,那么后续在画布上画的东西就等于在Bitmap上画的
     */
    Bitmap b = Bitmap.createBitmap(min, min, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(b);

    /**
     * 初始化画笔,设置抗锯齿
     */
    mPaint = new Paint();
    mPaint.setAntiAlias(true);

    /**
     * 首先画一个圆,和画布一样大
     */
    canvas.drawCircle(min / 2, min / 2, min / 2, mPaint);

    /**
     * 设置PoerterDuffXfermode参数,使后面画的和前面画的交集
     * 这样就等于在一个圆上画我们的图片,所以看到的就是一个圆形的图片了
     */
    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
    canvas.drawBitmap(mBitmap, 0, 0, mPaint);
    return b;
}
</code></pre><p>这样就好啦，运行程序就可以看到我们开始的效果啦~</p>
<p><strong>感谢鸿洋大神</strong></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/42094215" target="_blank" rel="noopener">原文地址</a></p>
<hr>
<h2 id="第二个实例-刮刮卡"><a href="#第二个实例-刮刮卡" class="headerlink" title="第二个实例  刮刮卡"></a>第二个实例  刮刮卡</h2><p>相信大家都玩过刮刮卡，记得没错好像是支付宝也弄过这个效果（好像是在支付成功后）</p>
<p>刮刮卡有两个图层，上面一层和下面的图片，上面的主要用来被刮掉，在初始状态下，上面的图层会掩盖住下面的图层，当用手刮上面的图层时，下面的会慢慢显示出来，这就需要用到DST_IN了。效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1822424-11f99be96020f64f.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h4 id="分如下几步-1"><a href="#分如下几步-1" class="headerlink" title="分如下几步"></a>分如下几步</h4><ol>
<li>初始化Paint和图片等</li>
<li>在onDraw()方法中绘制两个图片，首先绘制背景图，然后绘制遮罩层</li>
<li>在onTouchEvent()方法中绘制路径</li>
<li>使用DST_IN模式绘制在上图层就ok</li>
</ol>
<p>首先初始化，代码如下：</p>
<pre><code>private void init() {
    mPaint = new Paint();
    /**
     * 设置画笔透明度为0,设置PoerterDuffXfermode为DST_IN模式
     */
    mPaint.setAlpha(0);
    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
    mPaint.setStyle(Paint.Style.STROKE);
    mPaint.setStrokeJoin(Paint.Join.ROUND); //设置画笔图形样式
    mPaint.setStrokeCap(Paint.Cap.ROUND);   //设置画笔转弯连接处的风格
    mPaint.setStrokeWidth(50);  //设置宽度

    mPath = new Path();
    /**
     * 获取背景图片
     */
    mBgBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.a1);

    /**
     * 创建遮罩层Bitmap和背景图片一样大小,画上灰色
     */
    mFgBitmap = Bitmap.createBitmap(mBgBitmap.getWidth(), mBgBitmap.getHeight(), Bitmap.Config.ARGB_8888);
    mCanvas = new Canvas(mFgBitmap);
    mCanvas.drawColor(Color.GRAY);
}
</code></pre><p>然后绘制两个图层：</p>
<pre><code>protected void onDraw(Canvas canvas) {
    /**
     * 首先绘制背景图,然后绘制遮罩层,这样遮罩层才会在背景图上面
     */
    canvas.drawBitmap(mBgBitmap, 0, 0, null);
    canvas.drawBitmap(mFgBitmap, 0, 0, null);
}
</code></pre><p>最后在onTouchEvent()方法中绘制路径：</p>
<pre><code>public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        /**
         * 重置一下路径,移动到该点
         */
        case MotionEvent.ACTION_DOWN:
            mPath.reset();
            mPath.moveTo(event.getX(), event.getY());
            break;
        /**
         * 路径的点
         */
        case MotionEvent.ACTION_MOVE:
            mPath.lineTo(event.getX(), event.getY());
            break;
    }

    /**
     * 绘制路径,其实是在mFgBitmap上绘制
     * 并且由于DST_IN模式,取交集,透明度为0,所以就能实现刮刮卡的效果
     */
    mCanvas.drawPath(mPath, mPaint);

    /**
     * 通知重绘
     */
    invalidate();
    return true;
}
</code></pre><p>这样一个刮刮卡的效果就完成了，是不是很简单。</p>
<p><strong>需要注意的一点：在使用PorterDuffXfermode时，最好把硬件加速关闭，因为有的模式不支持硬件加速</strong></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>爱生活，爱小丽，爱Android</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http:/2018/04/13/Android/Android-Paint高级-PorterDuffXfermode/" data-id="cjfx8xuf00000qqfykur5st2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/13/Python/Python-学装饰器之前，有几个点要理解/">Python-学装饰器之前，有几个点要理解</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Python/Python-记学习对象可变性/">Python-记学习对象可变性</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义banner实现/">Android-自定义banner实现</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-自定义View/">Android - 自定义View</a>
          </li>
        
          <li>
            <a href="/2018/04/13/Android/Android-各种情况下的『自动加载更多』/">Android-各种情况下的『自动加载更多』</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 王璐<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>